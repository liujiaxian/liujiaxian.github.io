{"meta":{"title":"先修客","subtitle":"专业互联网开发","description":"专业互联网开发","author":"刘嘉先","url":"https://xxk.link"},"pages":[{"title":"关于我","date":"2018-07-27T06:24:41.000Z","updated":"2021-09-04T15:03:46.000Z","comments":true,"path":"about/index.html","permalink":"https://xxk.link/about/index.html","excerpt":"","text":"兴趣爱好骑行，游泳，篮球。"},{"title":"照片墙","date":"2018-12-27T06:24:41.000Z","updated":"2021-09-04T15:09:59.000Z","comments":true,"path":"photos/index.html","permalink":"https://xxk.link/photos/index.html","excerpt":"","text":""},{"title":"我的计划","date":"2021-09-04T07:10:00.000Z","updated":"2021-09-04T15:00:46.000Z","comments":true,"path":"dynamics/index.html","permalink":"https://xxk.link/dynamics/index.html","excerpt":"对过去要完成的事情做一个周祥的计划","text":"对过去要完成的事情做一个周祥的计划 自考备考专业代码 080901 专业名称 计算机科学与技术主考院校 华南理工大学 专业层次 本科课程设置 必考课16门74学分，加考课4门19学分。 自考科目已完成未完成结婚计划项目表已完成未完成"}],"posts":[{"title":"flarum 安装问题","slug":"category/服务器运维/flarum 安装问题","date":"2020-10-30T14:07:00.000Z","updated":"2021-09-04T06:33:48.000Z","comments":true,"path":"2020/10/30/category/服务器运维/flarum 安装问题/","link":"","permalink":"https://xxk.link/2020/10/30/category/服务器运维/flarum 安装问题/","excerpt":"PHP Warning Phar::mapPhar() open_basedir restriction in effect","text":"PHP Warning Phar::mapPhar() open_basedir restriction in effect PHP Warning: Phar::mapPhar(): open_basedir restriction in effectPHP Warning: Phar::mapPhar(): open_basedir restriction in effect. File(/usr/local/bin/composer) is not within the allowed path(s): (/srv/http/:/home/:/tmp/:/usr/share/pear/:/usr/share/webapps/) in /usr/local/bin/composer on line 13PHP Warning: require(phar://composer.phar/bin/composer): failed to open stream: phar error: invalid url or non-existent phar “phar://composer.phar/bin/composer” in /usr/local/bin/composer on line 15PHP Fatal error: require(): Failed opening required ‘phar://composer.phar/bin/composer’ (include_path=’.:/usr/share/pear’) in /usr/local/bin/composer on line 15 [color=blue]删除.user.ini文件或者修改 php的配置文件my.ini里的open_basedir=(应用程序目录)或者修改 nginx 的的配置文件fastcgi.conf里的fastcgi_param PHP_ADMIN_VALUE “open_basedir=(应用程序目录):/tmp/:/proc/“;[/color] PHP Fatal error: Class UpdateHelper\\ComposerPlugin contains 2PHP Fatal error: Class UpdateHelper\\ComposerPlugin contains 2 abstract methods and must therefore be declared abstract or implement the remaining methods (Composer\\Plugin\\PluginInterface::deactivate, Composer\\Plugin\\PluginInterface::uninstall) in /mnt/www/wwwroot/flarum/vendor/kylekatarnls/update-helper/src/UpdateHelper/ComposerPlugin.php on line 11 Fatal error: Class UpdateHelper\\ComposerPlugin contains 2 abstract methods and must therefore be declared abstract or implement the remaining methods (Composer\\Plugin\\PluginInterface::deactivate, Composer\\Plugin\\PluginInterface::uninstall) in /mnt/www/wwwroot/flarum/vendor/kylekatarnls/update-helper/src/UpdateHelper/ComposerPlugin.php on line 11[root@localhost flarum]# composer -vPHP Fatal error: Class UpdateHelper\\ComposerPlugin contains 2 abstract methods and must therefore be declared abstract or implement the remaining methods (Composer\\Plugin\\PluginInterface::deactivate, Composer\\Plugin\\PluginInterface::uninstall) in /mnt/www/wwwroot/flarum/vendor/kylekatarnls/update-helper/src/UpdateHelper/ComposerPlugin.php on line 11 Fatal error: Class UpdateHelper\\ComposerPlugin contains 2 abstract methods and must therefore be declared abstract or implement the remaining methods (Composer\\Plugin\\PluginInterface::deactivate, Composer\\Plugin\\PluginInterface::uninstall) in /mnt/www/wwwroot/flarum/vendor/kylekatarnls/update-helper/src/UpdateHelper/ComposerPlugin.php on line 11 [color=blue]进入你的项目/vendor/[/color]","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"flarum","slug":"flarum","permalink":"https://xxk.link/tags/flarum/"}]},{"title":"jenkins pipeline 通配符处理","slug":"category/服务器运维/jenkins pipeline 通配符处理","date":"2020-09-11T11:21:00.000Z","updated":"2021-09-04T06:18:38.000Z","comments":true,"path":"2020/09/11/category/服务器运维/jenkins pipeline 通配符处理/","link":"","permalink":"https://xxk.link/2020/09/11/category/服务器运维/jenkins pipeline 通配符处理/","excerpt":"编写 jenkins pipeline 执行一个sh “rm -f ${path}/jar” 出现问题，会在执行体上加引号导致执行语句没有成功，结果是 rm -f ‘${path}/jar’","text":"编写 jenkins pipeline 执行一个sh “rm -f ${path}/jar” 出现问题，会在执行体上加引号导致执行语句没有成功，结果是 rm -f ‘${path}/jar’ 查找解决方案1.通配符加单引号，通配符转义都不行2.通过eval ls 原文地址12345file_name=`eval ls *$yesterday_dir-*`tar_log()&#123; tar zcvf $log_time.tar.gz $file_name --remove-files mv $log_time.tar.gz $yesterday_dir &#125; 3.通过查找方式删除(我最后用的是这个方案解决了)1sh &quot;/bin/find $&#123;path&#125; -name &apos;\\\\*.jar&apos; -type f -exec /bin/rm -f &#123;&#125; +&quot;","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://xxk.link/tags/jenkins/"},{"name":"pipeline","slug":"pipeline","permalink":"https://xxk.link/tags/pipeline/"}]},{"title":"微信头像地址失效","slug":"category/java/微信头像地址失效","date":"2020-05-08T01:48:49.000Z","updated":"2021-09-04T05:57:41.000Z","comments":true,"path":"2020/05/08/category/java/微信头像地址失效/","link":"","permalink":"https://xxk.link/2020/05/08/category/java/微信头像地址失效/","excerpt":"开发过程中为了用户体验，没有限制用户上传图片，产品一定要有图片，用户没有上传图片情况下就使用用户头像，头像地址是存在数据库的，当用户微信头像换了，或者其他原因无法保证图片一定有效，就会导致项目中的图片无法查看，被用户投诉。","text":"开发过程中为了用户体验，没有限制用户上传图片，产品一定要有图片，用户没有上传图片情况下就使用用户头像，头像地址是存在数据库的，当用户微信头像换了，或者其他原因无法保证图片一定有效，就会导致项目中的图片无法查看，被用户投诉。 对比无法访问的图片响应内容12345678910Cache-Control: no-cacheContent-Length: 5093Content-Type: image/pngLast-Modified: Mon, 01 Jan 1990 00:00:00 GMTServer: ImgHttp3.0.0X-BCheck: 0_0X-Cpt: filename=0X-ErrNo: -6101X-Info: notexist:-6101X-RtFlag: 0 正常访问的图片响应12345678910111213141516Cache-Control: max-age=2592000chid: 0Content-Length: 3558Content-Type: image/jpegfid: 0Last-Modified: Sun, 03 Nov 2019 20:50:59 GMTServer: ImgHttp3.0.0Size: 3558User-ReturnCode: 0Vary: Accept,OriginX-BCheck: 0_1X-Cpt: filename=0X-DataSrc: 0X-Delay: 4443 usX-Info: real dataX-ReqGue: 0 通过对比可以发现，可以根据X-Info: notexist:-6101 判断或者 X-ErrNo: -6101 关键字 注意，不能通过状态去判断，因为都是返回200的状态的 获取响应代码123456789101112131415161718192021222324 public static boolean checkWechatPhoto(String photoUrl) &#123; try &#123; URL url = new URL(photoUrl); URLConnection conn = url.openConnection(); Map headers = conn.getHeaderFields(); Set&lt;String&gt; keys = headers.keySet(); for (String key : keys) &#123; String val = conn.getHeaderField(key);// System.out.println(key + &quot; &quot; + val);// System.out.println(conn.getLastModified()); if(StringUtils.isNotEmpty(key) &amp;&amp; key.equalsIgnoreCase(&quot;X-ErrNo&quot;))&#123; if(val.equalsIgnoreCase(&quot;-6101&quot;))&#123; return false; &#125;else&#123; break; &#125; &#125; &#125; &#125; catch (Exception e) &#123; log.error(e.getMessage()); &#125; return true; &#125; 总结后续的处理需要结合你的业务处理，可以写个定时任务，定时去处理这些无法访问的图片，也可以写个线程用户触发的时候去判断处理，方法很多这里不一一举例了。","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://xxk.link/tags/微信/"},{"name":"头像","slug":"头像","permalink":"https://xxk.link/tags/头像/"}]},{"title":"发送 上传文件的 post 请求","slug":"category/java/发送-上传文件的-post-请求","date":"2020-04-29T07:13:26.000Z","updated":"2021-09-04T05:55:18.000Z","comments":true,"path":"2020/04/29/category/java/发送-上传文件的-post-请求/","link":"","permalink":"https://xxk.link/2020/04/29/category/java/发送-上传文件的-post-请求/","excerpt":"最近公司对接第三方的接口，对方的接口有一个参数需要上传一个multipart文件，用常规的 post 的请求一直失败","text":"最近公司对接第三方的接口，对方的接口有一个参数需要上传一个multipart文件，用常规的 post 的请求一直失败 代码工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313package com.eryansky.modules.aiqiangua.utils;import com.alibaba.dubbo.common.logger.Logger;import com.alibaba.dubbo.common.logger.LoggerFactory;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import org.springframework.web.multipart.MultipartFile;import java.io.*;import java.net.HttpURLConnection;import java.net.URL;import java.util.HashMap;/** * HTTP请求对象 * * @author YYmmiinngg */public class HttpUtil &#123; private static Logger log = LoggerFactory.getLogger(HttpUtil.class); /** * 常规 get * @param requestUrl * @param cookie * @return */ public static JSONObject sendGet(String requestUrl, String cookie) &#123; log.info(&quot;url:&quot; + requestUrl); String res = &quot;&quot;; JSONObject object = null; StringBuffer buffer = new StringBuffer(); try &#123; URL url = new URL(requestUrl); HttpURLConnection urlCon = (HttpURLConnection) url.openConnection(); urlCon.setRequestProperty(&quot;cookie&quot;, cookie); // 设置cookie log.info(JSON.toJSONString(urlCon.getResponseCode())); if (200 == urlCon.getResponseCode()) &#123; InputStream is = urlCon.getInputStream(); InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;); BufferedReader br = new BufferedReader(isr); String str = null; while ((str = br.readLine()) != null) &#123; buffer.append(str); &#125; br.close(); isr.close(); is.close(); res = buffer.toString(); JSONObject parse = new JSONObject(); object = (JSONObject) parse.parse(res); &#125; else &#123; throw new Exception(&quot;连接失败&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return object; &#125; /** * 常规 post * @param strURL * @param jsonStr * @param cookie * @return */ public static JSONObject sendPost(String strURL, String jsonStr, String cookie) &#123; log.info(&quot;url:&quot; + strURL); OutputStreamWriter out = null; InputStream is = null; try &#123; URL url = new URL(strURL);// 创建连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); connection.setRequestMethod(&quot;POST&quot;); // 设置请求方式 connection.setRequestProperty(&quot;Accept&quot;, &quot;application/json&quot;); // 设置接收数据的格式 connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;); // 设置发送数据的格式 connection.setRequestProperty(&quot;cookie&quot;, cookie); // 设置cookie connection.connect(); out = new OutputStreamWriter(connection.getOutputStream(), &quot;UTF-8&quot;); // utf-8编码 out.append(jsonStr); out.flush(); out.close(); // 读取响应 is = connection.getInputStream(); int length = (int) connection.getContentLength();// 获取长度 if (length != -1) &#123; byte[] data = new byte[length]; byte[] temp = new byte[512]; int readLen = 0; int destPos = 0; while ((readLen = is.read(temp)) &gt; 0) &#123; System.arraycopy(temp, 0, data, destPos, readLen); destPos += readLen; &#125; String result = new String(data, &quot;UTF-8&quot;); // utf-8编码 return JSON.parseObject(result); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; is.close(); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; /** * post请求 不带file * 参数使用 * JSONObject jp = new JSONObject(); * String param = jp.toJSONString() */ public static JSONObject sendPostRequest(String fileOCRUrl, HashMap&lt;String, Object&gt; map, String cookie) &#123; DataOutputStream out = null; DataInputStream in = null; final String newLine = &quot;\\r\\n&quot;; final String prefix = &quot;--&quot;; JSONObject json = null; try &#123; URL url = new URL(fileOCRUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); String BOUNDARY = &quot;-------KingKe0520a&quot;; conn.setRequestMethod(&quot;POST&quot;); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); conn.setUseCaches(false); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;Charsert&quot;, &quot;UTF-8&quot;); conn.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + BOUNDARY); conn.setRequestProperty(&quot;cookie&quot;, cookie); // 设置cookie out = new DataOutputStream(conn.getOutputStream()); StringBuilder sb = new StringBuilder(); int k = 1; for (String key : map.keySet()) &#123; if (k != 1) &#123; sb.append(newLine); &#125; sb.append(prefix); sb.append(BOUNDARY); sb.append(newLine); sb.append(&quot;Content-Disposition: form-data;name=&quot; + key + &quot;&quot;); sb.append(newLine); sb.append(newLine); sb.append(map.get(key)); out.write(sb.toString().getBytes()); sb.delete(0, sb.length()); k++; &#125; byte[] end_data = (&quot;\\r\\n--&quot; + BOUNDARY + &quot;--\\r\\n&quot;).getBytes(); out.write(end_data); out.flush(); // 定义BufferedReader输入流来读取URL的响应 BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line = null; StringBuffer resultStr = new StringBuffer(); while ((line = reader.readLine()) != null) &#123; resultStr.append(line); &#125; json = (JSONObject) JSONObject.parse(resultStr.toString()); &#125; catch (Exception e) &#123; System.out.println(&quot;发送POST请求出现异常！&quot; + e); e.printStackTrace(); &#125; finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return json; &#125; /** * post请求 带file,map是其余参数 */ public static JSONObject sendPostWithFile(String fileOCRUrl, MultipartFile file, String fileKey, HashMap&lt;String, Object&gt; map, String cookie) &#123; DataOutputStream out = null; DataInputStream in = null; final String newLine = &quot;\\r\\n&quot;; final String prefix = &quot;--&quot;; JSONObject json = null; try &#123; URL url = new URL(fileOCRUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); String BOUNDARY = &quot;-------KingKe0520a&quot;; conn.setRequestMethod(&quot;POST&quot;); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); conn.setUseCaches(false); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;Charsert&quot;, &quot;UTF-8&quot;); conn.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + BOUNDARY); conn.setRequestProperty(&quot;cookie&quot;, cookie); // 设置cookie out = new DataOutputStream(conn.getOutputStream()); // 添加参数file // File file = new File(filePath); StringBuilder sb1 = new StringBuilder(); sb1.append(prefix); sb1.append(BOUNDARY); sb1.append(newLine); sb1.append(&quot;Content-Disposition: form-data;name=\\&quot;&quot;+fileKey+&quot;\\&quot;;filename=\\&quot;&quot; + file.getName() + &quot;\\&quot;&quot; + newLine); sb1.append(&quot;Content-Type:application/octet-stream&quot;); sb1.append(newLine); sb1.append(newLine); out.write(sb1.toString().getBytes()); // in = new DataInputStream(new FileInputStream(file)); in = new DataInputStream(file.getInputStream()); byte[] bufferOut = new byte[1024]; int bytes = 0; while ((bytes = in.read(bufferOut)) != -1) &#123; out.write(bufferOut, 0, bytes); &#125; out.write(newLine.getBytes()); StringBuilder sb = new StringBuilder(); int k = 1; for (String key : map.keySet()) &#123; if (k != 1) &#123; sb.append(newLine); &#125; sb.append(prefix); sb.append(BOUNDARY); sb.append(newLine); sb.append(&quot;Content-Disposition: form-data;name=&quot; + key + &quot;&quot;); sb.append(newLine); sb.append(newLine); sb.append(map.get(key)); out.write(sb.toString().getBytes()); sb.delete(0, sb.length()); k++; &#125; // 添加参数sysName /*StringBuilder sb = new StringBuilder(); sb.append(prefix); sb.append(BOUNDARY); sb.append(newLine); sb.append(&quot;Content-Disposition: form-data;name=\\&quot;sysName\\&quot;&quot;); sb.append(newLine); sb.append(newLine); sb.append(&quot;test&quot;); out.write(sb.toString().getBytes());*/ // 添加参数returnImage /*StringBuilder sb2 = new StringBuilder(); sb2.append(newLine); sb2.append(prefix); sb2.append(BOUNDARY); sb2.append(newLine); sb2.append(&quot;Content-Disposition: form-data;name=\\&quot;returnImage\\&quot;&quot;); sb2.append(newLine); sb2.append(newLine); sb2.append(&quot;false&quot;); out.write(sb2.toString().getBytes());*/ byte[] end_data = (&quot;\\r\\n--&quot; + BOUNDARY + &quot;--\\r\\n&quot;).getBytes(); out.write(end_data); out.flush(); // 定义BufferedReader输入流来读取URL的响应 BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line = null; StringBuffer resultStr = new StringBuffer(); while ((line = reader.readLine()) != null) &#123; resultStr.append(line); &#125; json = (JSONObject) JSONObject.parse(resultStr.toString()); &#125; catch (Exception e) &#123; System.out.println(&quot;发送POST请求出现异常！&quot; + e); e.printStackTrace(); &#125; finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return json; &#125;&#125; 通过 url 上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.eryansky.modules.aiqiangua.utils;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileItemFactory;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.http.entity.ContentType;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.commons.CommonsMultipartFile;import java.io.*;import java.net.HttpURLConnection;import java.net.URL;public class FileUtil &#123; /** * url转变为 MultipartFile对象 * @param url * @param fileName * @return * @throws Exception */ public static MultipartFile createFileItem(String url, String fileName) throws Exception&#123; FileItem item = null; try &#123; HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection(); conn.setReadTimeout(30000); conn.setConnectTimeout(30000); //设置应用程序要从网络连接读取数据 conn.setDoInput(true); conn.setRequestMethod(&quot;GET&quot;); if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) &#123; InputStream is = conn.getInputStream(); FileItemFactory factory = new DiskFileItemFactory(16, null); String textFieldName = fileName; item = factory.createItem(textFieldName, ContentType.APPLICATION_OCTET_STREAM.toString(), false, fileName); OutputStream os = item.getOutputStream(); int bytesRead = 0; byte[] buffer = new byte[8192]; while ((bytesRead = is.read(buffer, 0, 8192)) != -1) &#123; os.write(buffer, 0, bytesRead); &#125; os.close(); is.close(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(&quot;文件下载失败&quot;, e); &#125; return new CommonsMultipartFile(item); &#125; /** * MultipartFile 转 File * * @param file * @throws Exception */ public static File multipartFileToFile(MultipartFile file) throws Exception &#123; File toFile = null; if (file.equals(&quot;&quot;) || file.getSize() &lt;= 0) &#123; file = null; &#125; else &#123; InputStream ins = null; ins = file.getInputStream(); toFile = new File(file.getOriginalFilename()); inputStreamToFile(ins, toFile); ins.close(); &#125; return toFile; &#125; //获取流文件 public static void inputStreamToFile(InputStream ins, File file) &#123; try &#123; OutputStream os = new FileOutputStream(file); int bytesRead = 0; byte[] buffer = new byte[8192]; while ((bytesRead = ins.read(buffer, 0, 8192)) != -1) &#123; os.write(buffer, 0, bytesRead); &#125; os.close(); ins.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 删除本地临时文件 * @param file */ public static void delteTempFile(File file) &#123; if (file != null) &#123; File del = new File(file.toURI()); del.delete(); &#125; &#125;&#125; 调用 直接调用 key 是上传文件的 key ， cookie 是对方接口访问授权，可以根据自己的业务逻辑修改 1234567891011121314151617181920212223/** * 测试 * * @param request */ @ApiOperation(&quot;测试&quot;) @RequestMapping(value = &#123;&quot;test&quot;&#125;, method = RequestMethod.POST) @ResponseBody public Result test(HttpServletRequest request, Integer type, @RequestParam(value = &quot;file&quot;, required = false) MultipartFile file) &#123; try &#123; //url 的调用 String cookie = &quot;第三方授权返回的cookie&quot;; HashMap&lt;String, Object&gt; params = new HashMap&lt;&gt;(); if (type != null) &#123; file = FileUtil.createFileItem(&quot;远程文件地址&quot;, &quot;文件名称例如123.png&quot;); &#125; JSONObject result = HttpRequester.sendPostWithFile(&quot;接口地址&quot;, file, &quot;key&quot;, params, cookie); return Result.success().setData(result); &#125;catch (Exception e)&#123; logger.error(e.getMessage(), e); return Result.error().setMsg(e.getMessage()); &#125; &#125; 总结参考文章 出现问题不可怕，关键是要定位到问题的关键，才能快速解决问题！","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"文件","slug":"文件","permalink":"https://xxk.link/tags/文件/"},{"name":"post","slug":"post","permalink":"https://xxk.link/tags/post/"}]},{"title":"ImportError No module named tqdm","slug":"category/nodejs/ImportError No module named tqdm","date":"2020-04-09T09:47:00.000Z","updated":"2021-09-04T06:10:27.000Z","comments":true,"path":"2020/04/09/category/nodejs/ImportError No module named tqdm/","link":"","permalink":"https://xxk.link/2020/04/09/category/nodejs/ImportError No module named tqdm/","excerpt":"node 项目执行报错没有安装模块 tqdm ,然后立马安装了该模块，但是执行还是提示没有安装该模块","text":"node 项目执行报错没有安装模块 tqdm ,然后立马安装了该模块，但是执行还是提示没有安装该模块 错误提示1234Traceback (most recent call last):File &quot;main.py&quot;, line 15, inimport tqdmModuleNotFoundError: No module named &apos;tqdm&apos; 安装模块1pip3 install tqdm 提示安装成功了，执行后提示没有安装 解决方法[colorr]原因是的pip3和python3不匹配[/colorr] 1python3 -m pip3 install tqdm 本人没有学习过 nodejs 所有导致问题产生不知道如何解决，最终通过网络搜索出解决方法 原文地址","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxk.link/categories/nodejs/"}],"tags":[{"name":"ImportError","slug":"ImportError","permalink":"https://xxk.link/tags/ImportError/"},{"name":"tqdm","slug":"tqdm","permalink":"https://xxk.link/tags/tqdm/"}]},{"title":"抖音用户关注设计方案","slug":"category/java/抖音用户关注设计方案","date":"2020-04-01T10:06:04.000Z","updated":"2021-09-04T05:54:58.000Z","comments":true,"path":"2020/04/01/category/java/抖音用户关注设计方案/","link":"","permalink":"https://xxk.link/2020/04/01/category/java/抖音用户关注设计方案/","excerpt":"最近公司需要做一个类似抖音的用户关注、粉丝模块，当然不仅仅是查关注用户和粉丝用户，主要是查用户的关注、粉丝用户和当前登录用户的关系，这个有点绕！","text":"最近公司需要做一个类似抖音的用户关注、粉丝模块，当然不仅仅是查关注用户和粉丝用户，主要是查用户的关注、粉丝用户和当前登录用户的关系，这个有点绕！ 表设计这里创建了两张表一张用户关注和被关注的关系表，另外的一张为日志表，具体按你的业务逻辑设计，切忌不要将用户和被关注的用户记录数只记录一条，后面查询会非常复杂，本人亲测 123456789101112131415161718192021CREATE TABLE `t_base_custom_follow` ( `id` varchar(32) NOT NULL COMMENT &apos;主键 id&apos;, `custom_id` varchar(32) NOT NULL COMMENT &apos;关注用户&apos;, `be_custom_id` varchar(32) NOT NULL COMMENT &apos;被关注用户&apos;, `create_time` datetime NOT NULL COMMENT &apos;关注时间&apos;, `update_time` datetime NOT NULL COMMENT &apos;更新时间&apos;, `status` int(1) NOT NULL COMMENT &apos;状态 0关注 1相互关注 2拉黑&apos;, PRIMARY KEY (`id`), UNIQUE KEY `custom_id_union` (`custom_id`,`be_custom_id`) USING BTREE COMMENT &apos;唯一索引&apos;, KEY `custom_id` (`custom_id`) USING BTREE COMMENT &apos;关注用户&apos;, KEY `be_custom_id` (`be_custom_id`) USING BTREE COMMENT &apos;被关注用户&apos;) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;用户关注关系表&apos;;CREATE TABLE `t_base_custom_follow_log` ( `id` varchar(32) NOT NULL COMMENT &apos;主键 id&apos;, `custom_id` varchar(32) NOT NULL COMMENT &apos;关注用户&apos;, `be_custom_id` varchar(32) NOT NULL COMMENT &apos;被关注用户&apos;, `create_time` datetime NOT NULL COMMENT &apos;关注时间&apos;, `type` int(1) NOT NULL COMMENT &apos;类型 0关注 1取消关注&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;用户关注关系记录表&apos;; 功能模块关注和取消关注123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public Integer updateFollow(String customId, String beCustomId, Integer type) &#123; Assert.hasText(customId, &quot;参数错误&quot;); Assert.hasText(beCustomId, &quot;参数错误&quot;); Assert.notNull(type, &quot;参数错误&quot;); Integer status = 0; TBaseCustomFollow model = tBaseCustomFollowMapper.getFollowInfo(customId, beCustomId); if (type == 0) &#123; //关注 Assert.isTrue(!customId.equalsIgnoreCase(beCustomId), &quot;不能关注自己&quot;); Assert.isNull(model, &quot;已经关注了&quot;); TBaseCustomFollow isFollow = tBaseCustomFollowMapper.getFollowInfo(beCustomId, customId); if(isFollow!=null)&#123; status = 1; isFollow.setStatus(1); isFollow.setUpdateTime(new Date()); this.updateByPKNotNull(isFollow); &#125; model = new TBaseCustomFollow(); model.setCustomId(customId); model.setBeCustomId(beCustomId); model.setCreateTime(new Date()); model.setId(null); model.setStatus(status); model.setUpdateTime(new Date()); this.saveNotNull(model); &#125; else &#123; Assert.isTrue(!customId.equalsIgnoreCase(beCustomId), &quot;不能取消关注自己&quot;); //取消关注 Assert.notNull(model, &quot;还未关注，不能取消&quot;); this.deleteByPK(model.getId()); TBaseCustomFollow isFollow = tBaseCustomFollowMapper.getFollowInfo(beCustomId, customId); if(isFollow!=null)&#123; isFollow.setStatus(0); isFollow.setUpdateTime(new Date()); this.updateByPKNotNull(isFollow); &#125; status = 2; &#125; TBaseCustomFollowLog logModel = new TBaseCustomFollowLog(); logModel.setCustomId(customId); logModel.setBeCustomId(beCustomId); logModel.setCreateTime(new Date()); logModel.setType(type); itBaseCustomFollowLogService.saveNotNull(logModel); return status; &#125; 关注、粉丝列表123456789public PageInfo getFollowList(TBaseCustomFollow model) &#123; Assert.hasText(model.getCustomId(), &quot;参数错误&quot;); Assert.notNull(model.getType(), &quot;参数错误&quot;); Assert.hasText(model.getUserId(), &quot;请登录&quot;); Assert.hasText(model.getCustomId(), &quot;用户id不能为空&quot;); doPage(model.getPageNo(), model.getPageSize()); return new PageInfo(tBaseCustomFollowMapper.getFollowList(model)); &#125; mybatis sql 语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;select id=&quot;getFollowList&quot; resultType=&quot;com.kanglefucn.business.admin.dao.model.TBaseCustomFollow&quot;&gt; &lt;if test=&quot;type==0&quot;&gt; select A.id, A.create_time createTime, A.update_time updateTime, A.be_custom_id customId, &lt;if test=&quot;userId==customId&quot;&gt; A.`status` &apos;userStatus&apos;, &lt;/if&gt; &lt;if test=&quot;userId!=customId&quot;&gt; IF(tt.status is null,2,tt.status) &apos;userStatus&apos;, &lt;/if&gt; B.nickname userName, IFNULL(B.oss_pictureurl, C.headimgurl) headerUrl from t_base_custom_follow A left join t_base_custom B on A.be_custom_id = B.id left join t_base_custom_wechat C ON B.id = C.accountid &lt;if test=&quot;userId!=customId&quot;&gt; left join ( select B.status,A.be_custom_id from t_base_custom_follow A left join t_base_custom_follow B on (A.be_custom_id = B.custom_id and B.be_custom_id = #&#123;userId&#125;) where A.custom_id = #&#123;customId&#125; group by A.custom_id,A.be_custom_id ) tt on A.be_custom_id = tt.be_custom_id &lt;/if&gt; where A.custom_id = #&#123;customId&#125; order by A.create_time desc &lt;/if&gt; &lt;if test=&quot;type==1&quot;&gt; select A.id, A.create_time createTime, A.update_time updateTime, A.custom_id customId, IF(tt.status is null,2,tt.status) &apos;userStatus&apos;, B.nickname userName, IFNULL(B.oss_pictureurl, C.headimgurl) headerUrl from t_base_custom_follow A left join t_base_custom B on A.custom_id = B.id left join t_base_custom_wechat C ON B.id = C.accountid &lt;if test=&quot;userId!=customId&quot;&gt; left join ( SELECT B.STATUS,A.custom_id FROM t_base_custom_follow A left join t_base_custom_follow B on (A.custom_id = B.be_custom_id and B.custom_id = #&#123;userId&#125;) WHERE A.be_custom_id = #&#123;customId&#125; GROUP BY A.custom_id, A.be_custom_id ) tt on A.custom_id = tt.custom_id &lt;/if&gt; &lt;if test=&quot;userId==customId&quot;&gt; left join (select status,be_custom_id from t_base_custom_follow where custom_id = #&#123;customId&#125; group by custom_id,be_custom_id ) tt on A.custom_id = tt.be_custom_id &lt;/if&gt; where A.be_custom_id = #&#123;customId&#125; order by A.create_time desc &lt;/if&gt; &lt;/select&gt; 查询关注、粉丝数mybatis sql 语句 12345678910111213&lt;select id=&quot;getFollowCount&quot; resultType=&quot;map&quot;&gt; select sum(followCount) followCount,sum(t.beFollowCount) beFollowCount from( select count(1) followCount,0 beFollowCount from t_base_custom_follow where custom_id = #&#123;customId&#125; union all select 0 followCount, count(1) beFollowCount from t_base_custom_follow where be_custom_id = #&#123;customId&#125; ) t &lt;/select&gt; 总结 现阶段先这样使用着先吧，设计是开发效率最大的提升，设计的好，你写代码事半功倍，设计不好，代码写的复杂，效率性能也差，如果你有更好的方案，请留言，谢谢指教","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"用户关注","slug":"用户关注","permalink":"https://xxk.link/tags/用户关注/"},{"name":"设计","slug":"设计","permalink":"https://xxk.link/tags/设计/"}]},{"title":"ELK 日志分析系统搭建","slug":"category/服务器运维/ELK 日志分析系统搭建","date":"2020-03-17T08:15:00.000Z","updated":"2021-09-04T06:13:11.000Z","comments":true,"path":"2020/03/17/category/服务器运维/ELK 日志分析系统搭建/","link":"","permalink":"https://xxk.link/2020/03/17/category/服务器运维/ELK 日志分析系统搭建/","excerpt":"在过往的单体应用时代，我们所有组件都部署到一台服务器中，那时日志管理平台的需求可能并没有那么强烈，我们只需要登录到一台服务器通过shell命令就可以很方便的查看系统日志，并快速定位问题。","text":"在过往的单体应用时代，我们所有组件都部署到一台服务器中，那时日志管理平台的需求可能并没有那么强烈，我们只需要登录到一台服务器通过shell命令就可以很方便的查看系统日志，并快速定位问题。 在过往的单体应用时代，我们所有组件都部署到一台服务器中，那时日志管理平台的需求可能并没有那么强烈，我们只需要登录到一台服务器通过shell命令就可以很方便的查看系统日志，并快速定位问题。 安装1sudo docker pull sebp/elk 1sudo docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk sebp/elk [colorr]如果出现Elasticsearch等待安装失败的提示请执行下面的设置[/colorr] 查询虚拟内存值1sysctl vm.max_map_count 如果不是[colorg]262144[/colorg]请更新此值，教程 1sysctl -w vm.max_map_count=262144 访问 http://:5601 成功即安装完成","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"ELK","slug":"ELK","permalink":"https://xxk.link/tags/ELK/"},{"name":"日志","slug":"日志","permalink":"https://xxk.link/tags/日志/"}]},{"title":"异步回调重复处理","slug":"category/java/异步回调重复处理","date":"2020-03-11T06:34:30.000Z","updated":"2021-09-04T05:57:56.000Z","comments":true,"path":"2020/03/11/category/java/异步回调重复处理/","link":"","permalink":"https://xxk.link/2020/03/11/category/java/异步回调重复处理/","excerpt":"现在对接第三方接口很多情况都会有异步回调模块，微信支付、网易云信等都有，回调不仅是一次的，多次的情况如何避免多次重复调用问题呢？","text":"现在对接第三方接口很多情况都会有异步回调模块，微信支付、网易云信等都有，回调不仅是一次的，多次的情况如何避免多次重复调用问题呢？ 正常处理使用队列和线程1.通过回调方法解密回调内容，将内容放到队列中，防止频繁的调用数据库 io 频繁，导致数据库崩溃2.用线程往队列里取数据进行处理，排队处理不会出现并发等问题产生 使用消息中间件1.通过回调方法解密回调内容，将内容添加到消息队列中2.通过处理成功才提交，保证消息被消费到，没有处理成功的消息会继续消费，直到成功为止 缺点就是多次请求没有去重复处理 解决重复问题使用 redis或者静态 map,回调内容通过将内容的唯一属性值作为 key,存在则跳过，不会加入到队列中 redis 的时候需要设置失效时间，具体按照你的业务来设置，例如回调大概就几秒钟以内，你可以设置成10秒已上将数据清除","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://xxk.link/tags/异步/"},{"name":"回调","slug":"回调","permalink":"https://xxk.link/tags/回调/"}]},{"title":"ssh连接终端工具推荐","slug":"category/服务器运维/jssh连接终端工具推荐","date":"2020-02-25T02:30:00.000Z","updated":"2021-09-04T06:14:36.000Z","comments":true,"path":"2020/02/25/category/服务器运维/jssh连接终端工具推荐/","link":"","permalink":"https://xxk.link/2020/02/25/category/服务器运维/jssh连接终端工具推荐/","excerpt":"这些年用了很多终端工具，xshell、finalshell、shellcraft等等，不是收费就是有限制，不能多端同步","text":"这些年用了很多终端工具，xshell、finalshell、shellcraft等等，不是收费就是有限制，不能多端同步 这里给大家推荐一款 termius 工具，非常强大，基本把那些工具的短板都克服了 特点 免费 支持用户名密码和密钥模式 常用脚本片段（同时发送到多个主机） 全平台 云同步（注册一个账号即可） 分屏模式（看到有人提到，目前还没找到如何设置） 配置 Terminal（主题、配色、字体等） Shotcuts（快捷键） Known Hosts（主机地址管理） Keychain（登录信息管理） Profile（账号信息） 配置密钥打开 [colorb]preferences/Keychain/new key (ADD IDENTITY是用户名密码模式）[/colorb] 私钥在用户目录下的[colorg]/.ssh/id_rsa[/colorg]，然后将其内容全部复制粘贴到[colorr]Private key[/colorr]中。 Label（给该配置取个名字） Passphrase（生成密钥时设置的密码，如果没有设置，此处不填） Private key（私钥） Public key（公钥，可以不填） 配置主机host Address（主机地址） Port（主机端口，SSH默认为22） Username（用于登录主机的用户名） Password（密钥模式不需要填，点击右边的Keys-&gt;选择我们之前配置好的密钥） Group（分组，可以以环境维度分组，也可以以业务维度分组，看自己习惯） Start Snippet（登录后默认执行的脚本，可以在程序左侧的Snippet中添加）","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://xxk.link/tags/jenkins/"},{"name":"pipeline","slug":"pipeline","permalink":"https://xxk.link/tags/pipeline/"}]},{"title":"网易云信 im 如何保证在线状态准确？","slug":"category/java/网易云信-im-如何保证在线状态准确？","date":"2020-02-24T07:36:58.000Z","updated":"2021-09-04T05:57:13.000Z","comments":true,"path":"2020/02/24/category/java/网易云信-im-如何保证在线状态准确？/","link":"","permalink":"https://xxk.link/2020/02/24/category/java/网易云信-im-如何保证在线状态准确？/","excerpt":"公司对接了网易云信 im，一堆毛病，特别是在线状态不准确，用户已经离线却没有及时更新状态","text":"公司对接了网易云信 im，一堆毛病，特别是在线状态不准确，用户已经离线却没有及时更新状态 分析 由于网易没有给出状态查询的接口，可能考虑到很多情况导致状态查询数据量过大，没有给出这个接口 经过网易云信给出的 api，一方面通过网易云信回调的抄送进行用户在线状态更新，此时抄送可能丢失或延迟，另一方面则通过订阅用户的在线状态，判断用户在线情况，服务端通过用户最新登录时间和抄送的时间比对，大于最近登录时间才更新状态，否则忽略 api 接口关于在线状态事件订阅","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"网易云信","slug":"网易云信","permalink":"https://xxk.link/tags/网易云信/"},{"name":"im","slug":"im","permalink":"https://xxk.link/tags/im/"}]},{"title":"solrcore is not available due to init failure: Error opening new searcher","slug":"category/java/solrcore-is-not-available-due-to-init-failure-Error-opening-new-searcher","date":"2020-02-24T07:23:27.000Z","updated":"2021-09-04T06:03:25.000Z","comments":true,"path":"2020/02/24/category/java/solrcore-is-not-available-due-to-init-failure-Error-opening-new-searcher/","link":"","permalink":"https://xxk.link/2020/02/24/category/java/solrcore-is-not-available-due-to-init-failure-Error-opening-new-searcher/","excerpt":"服务器 solrt 突然挂了，查看solr控制面板和日志都报这个错误，没有做任何更新，网上查阅资料解决","text":"服务器 solrt 突然挂了，查看solr控制面板和日志都报这个错误，没有做任何更新，网上查阅资料解决 原文From the feedback received from @Haneen Daoud, I have looked at my corrupted cores in slave Solr. I see all the folders for the corrupted cores are present and understood from the logs that one of the segments of index is corrupted because of 100% memory utilization happened which is because of few error logs. I see conf, data folders and core.properties text file in the /var/Solr/data/Sitecore_analytics_index core. Data folder under path /var/Solr/data/Sitecore_analytics_index has the index folder and index.properties, replication.properties text files. I have deleted this data folder and restarted solr and this fixed the issue. 翻译找到你的 solr 节点目录，将目录 [colorb]data/index/[/colorb] 下面的所有删除，重启 solr 即可 [u]一开始网上查阅资料的时候，有人说只需要删除文件[colorg]data/index/write.lock[/colorg]，经过测试不行 [/u]","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"solrcore","slug":"solrcore","permalink":"https://xxk.link/tags/solrcore/"},{"name":"failure","slug":"failure","permalink":"https://xxk.link/tags/failure/"}]},{"title":"vsc golang环境搭建教程","slug":"category/golang/vsc-golang环境搭建教程","date":"2020-01-21T02:38:07.000Z","updated":"2021-09-04T05:54:36.000Z","comments":true,"path":"2020/01/21/category/golang/vsc-golang环境搭建教程/","link":"","permalink":"https://xxk.link/2020/01/21/category/golang/vsc-golang环境搭建教程/","excerpt":"任何编程语言都需要一款 ide 工具，那么这里选择一款微软开源的 vs code","text":"任何编程语言都需要一款 ide 工具，那么这里选择一款微软开源的 vs code 开始安装 请自行安装 go环境知道 go env 能看到正常的信息，下载 vsc 软件，并安装go扩展 [u]Rich Go language support for Visual Studio Code[/u] 任意创建一个 go 文件 123456789package mainimport ( &quot;fmt&quot;)func main() &#123; // 声明 main 主函数 fmt.Println(&quot;Hello World!&quot;) // 打印 Hello World!&#125; 此时 vsc 编辑器就会提示安装一些依赖,选择安装所有，如果由于谷歌被墙导致安装失败，那么此时就需要科学上网工具了，有些人已经翻墙了，但是还是下载失败，这是为何？因为终端没有代理。 设置代理打开 vsc 设置 首选项-&gt;设置-&gt;应用程序-&gt;代理服务器-&gt;Proxy输入你的代理地址，如果没有科学上网，那么可以选择别的代理网站 如果科学上网了，请查看自己的工具里的 http 代理设置的端口号 [colorg]http://127.0.0.1:1208[/colorg]，别看错了使用 socket5的端口了。 推荐代理网站如下 七牛云 阿里云 推荐 go sdk 环境设置vsc 设置 首选项-&gt;设置-&gt;扩展-&gt; go configuration-&gt;编辑 settings.json文件将 go env 里的这两个目录设置进去12 &quot;go.goroot&quot;: &quot;&quot;, &quot;go.gopath&quot;: &quot;&quot;, 调试运行按 F5调试看看是否能够正常运行，有问题继续往下看 问题1:[colorr]go: cannot find main module; see ‘go help modules’[/colorr]需要在根目录创建一个 go.mod 文件 1go init go.mod 问题2:[colorr]go: cannot determine module path for source directory /Users/liujiaxian/go (outside GOPATH, no import comments)[/colorr] 1go mod init github.com/jiajunhuang/hello 问题3:[colorr]$GOPATH/go.mod exists but should not[/colorr]把项目放到了 gopath 目录下了，应该移到别的地方去，就可以了 总结 我也是刚学的小白，有人和我一样踩坑，希望看到可以少走一些弯路，谢谢！","categories":[{"name":"golang","slug":"golang","permalink":"https://xxk.link/categories/golang/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://xxk.link/tags/环境搭建/"},{"name":"教程","slug":"教程","permalink":"https://xxk.link/tags/教程/"}]},{"title":"web 日志浏览面板log.io","slug":"category/服务器运维/web 日志浏览面板(log-io)","date":"2019-12-31T07:05:00.000Z","updated":"2021-09-04T06:16:37.000Z","comments":true,"path":"2019/12/31/category/服务器运维/web 日志浏览面板(log-io)/","link":"","permalink":"https://xxk.link/2019/12/31/category/服务器运维/web 日志浏览面板(log-io)/","excerpt":"tomcat 日志查看很头疼，特别是多个的时候，每次得打开终端来回的敲命令，效率比较低，那么有没有一款日志管理平台，直接 web 端可以对日志进行管理的工具，今天找了很多，有一款勉强可用，就是log.io","text":"tomcat 日志查看很头疼，特别是多个的时候，每次得打开终端来回的敲命令，效率比较低，那么有没有一款日志管理平台，直接 web 端可以对日志进行管理的工具，今天找了很多，有一款勉强可用，就是log.io log.io 安装方法安装log.io 需要提前安装nodejs,版本太低会安装失败，亲测11.6.0成功安装 1sudo npm install -g log.io --user &quot;root&quot; 下载源码1git clone https://github.com/NarrativeScience/Log.io.git 配置文件此[colorg]~/.log.io/[/colorg]目录下有三个配置文件分别是[colorg] log_server.conf [/colorg]、[colorg]harvester.conf[/colorg]、[colorg] web_server.conf[/colorg] log_server.conf 服务端地址和端口1234exports.config = &#123; host: &apos;0.0.0.0&apos;, port: 28777&#125; harvester.conf 客户端配置节点日志信息，并且指定服务端的地址和端口123456789101112131415vim ~/.log.io/harvester.confexports.config = &#123; nodeName: &quot;application_server&quot;, #[colorr]节点名称[/colorr] logStreams: &#123; apache: [ #[colorr]项目名称[/colorr] &quot;/var/log/apache2/access.log&quot;, #[colorr]日志路径[/colorr] &quot;/var/log/apache2/error.log&quot; ] &#125;, server: &#123; host: &apos;0.0.0.0&apos;, port: 28777 &#125; &#125; web_server.conf 日志 web 端信息配置123456789101112131415161718192021222324252627282930exports.config = &#123; host: &apos;127.0.0.1&apos;, port: 11111, /* // Enable HTTP Basic Authentication auth: &#123; user: &quot;admin&quot;, pass: &quot;123456&quot; &#125;, */ /* // Enable HTTPS/SSL ssl: &#123; key: &apos;/path/to/privatekey.pem&apos;, cert: &apos;/path/to/certificate.pem&apos; &#125;, */ /* // Restrict access to websocket (socket.io) // Uses socket.io &apos;origins&apos; syntax restrictSocket: &apos;*:*&apos;, */ /* // Restrict access to http server (express) restrictHTTP: [ &quot;192.168.29.39&quot;, &quot;10.0.*&quot; ] */&#125; 开启服务先开启服务端项目 bin 目录下执行 [colorb]log.io-server[/colorb] 再开启客户端项目 bin 目录下执行 [colorb]log.io-harvester[/colorb] 访问地址 [colort]127.0.0.1:11111[/colort]总结 感觉没有存到数据库，如果有入库的话就更好了，那么就可以查看以往的数据日志了，还能对库中数据进行分词搜索，可能实现起来会有瓶颈吧。","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://xxk.link/tags/日志/"},{"name":"web","slug":"web","permalink":"https://xxk.link/tags/web/"}]},{"title":"安装docker-compose失败","slug":"category/服务器运维/安装docker-compose失败","date":"2019-12-28T08:13:00.000Z","updated":"2021-09-04T06:18:21.000Z","comments":true,"path":"2019/12/28/category/服务器运维/安装docker-compose失败/","link":"","permalink":"https://xxk.link/2019/12/28/category/服务器运维/安装docker-compose失败/","excerpt":"系统 CentOS 7.6 64bit with ARM 内核 4.14.0-115.5.1.el7a.aarch64","text":"系统 CentOS 7.6 64bit with ARM 内核 4.14.0-115.5.1.el7a.aarch64 方式一1curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 1chmod +x /usr/local/bin/docker-compose 1docker-compose --version 错误提示[colorr]/usr/local/bin/docker-compose: line 1: Not: command not found[/colorr] 方式二1yum -y install epel-release 1yum -y install python-pip 1pip install docker-compose 1docker-compose --version 错误提示DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won’t be maintained after that date. A future version of pip will drop support for Python 2.7. More details about Python 2 support in pip, can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-supportCollecting docker-compose Using cached https://files.pythonhosted.org/packages/2e/93/b8fb6532487fcc40f5c607ac428a609e7f74bfb26a1c3c980a253c6e5a14/docker_compose-1.25.0-py2.py3-none-any.whlCollecting docker[ssh]&lt;5,&gt;=3.7.0 Using cached https://files.pythonhosted.org/packages/cc/ca/699d4754a932787ef353a157ada74efd1ceb6d1fc0bfb7989ae1e7b33111/docker-4.1.0-py2.py3-none-any.whlCollecting backports.shutil-get-terminal-size==1.0.0; python_version &lt; “3.3” Using cached https://files.pythonhosted.org/packages/7d/cd/1750d6c35fe86d35f8562091737907f234b78fdffab42b29c72b1dd861f4/backports.shutil_get_terminal_size-1.0.0-py2.py3-none-any.whlCollecting docopt&lt;1,&gt;=0.6.1 Using cached https://files.pythonhosted.org/packages/a2/55/8f8cab2afd404cf578136ef2cc5dfb50baa1761b68c9da1fb1e4eed343c9/docopt-0.6.2.tar.gzRequirement already satisfied: six&lt;2,&gt;=1.3.0 in /usr/lib/python2.7/site-packages (from docker-compose) (1.10.0)Requirement already satisfied: requests&lt;3,&gt;=2.20.0 in /usr/lib/python2.7/site-packages (from docker-compose) (2.22.0)Collecting dockerpty&lt;1,&gt;=0.4.1 Using cached https://files.pythonhosted.org/packages/8d/ee/e9ecce4c32204a6738e0a5d5883d3413794d7498fe8b06f44becc028d3ba/dockerpty-0.4.1.tar.gzCollecting websocket-client&lt;1,&gt;=0.32.0 Using cached https://files.pythonhosted.org/packages/29/19/44753eab1fdb50770ac69605527e8859468f3c0fd7dc5a76dd9c4dbd7906/websocket_client-0.56.0-py2.py3-none-any.whlCollecting texttable&lt;2,&gt;=0.9.0 Using cached https://files.pythonhosted.org/packages/82/a8/60df592e3a100a1f83928795aca210414d72cebdc6e4e0c95a6d8ac632fe/texttable-1.6.2.tar.gzRequirement already satisfied: ipaddress&lt;2,&gt;=1.0.16; python_version &lt; “3.3” in /usr/lib/python2.7/site-packages (from docker-compose) (1.0.16)Collecting cached-property&lt;2,&gt;=1.2.0 Using cached https://files.pythonhosted.org/packages/3b/86/85c1be2e8db9e13ef9a350aecd6dea292bd612fa288c2f40d035bb750ded/cached_property-1.5.1-py2.py3-none-any.whlCollecting subprocess32&lt;4,&gt;=3.5.4; python_version &lt; “3.2” Using cached https://files.pythonhosted.org/packages/32/c8/564be4d12629b912ea431f1a50eb8b3b9d00f1a0b1ceff17f266be190007/subprocess32-3.5.4.tar.gzCollecting enum34&lt;2,&gt;=1.0.4; python_version &lt; “3.4” Using cached https://files.pythonhosted.org/packages/c5/db/e56e6b4bbac7c4a06de1c50de6fe1ef3810018ae11732a50f15f62c7d050/enum34-1.1.6-py2-none-any.whlRequirement already satisfied: backports.ssl-match-hostname&lt;4,&gt;=3.5; python_version &lt; “3.5” in /usr/lib/python2.7/site-packages (from docker-compose) (3.5.0.1)Requirement already satisfied: PyYAML&lt;5,&gt;=3.10 in /usr/lib64/python2.7/site-packages (from docker-compose) (3.12)Collecting jsonschema&lt;4,&gt;=2.5.1 Using cached https://files.pythonhosted.org/packages/c5/8f/51e89ce52a085483359217bc72cdbf6e75ee595d5b1d4b5ade40c7e018b8/jsonschema-3.2.0-py2.py3-none-any.whlCollecting paramiko&gt;=2.4.2; extra == “ssh” Using cached https://files.pythonhosted.org/packages/4b/80/74dace9e48b0ef923633dfb5e48798f58a168e4734bca8ecfaf839ba051a/paramiko-2.6.0-py2.py3-none-any.whlRequirement already satisfied: certifi&gt;=2017.4.17 in /usr/lib/python2.7/site-packages (from requests&lt;3,&gt;=2.20.0-&gt;docker-compose) (2019.9.11)Requirement already satisfied: urllib3!=1.25.0,!=1.25.1,&lt;1.26,&gt;=1.21.1 in /usr/lib/python2.7/site-packages (from requests&lt;3,&gt;=2.20.0-&gt;docker-compose) (1.25.7)Requirement already satisfied: idna&lt;2.9,&gt;=2.5 in /usr/lib/python2.7/site-packages (from requests&lt;3,&gt;=2.20.0-&gt;docker-compose) (2.8)Requirement already satisfied: chardet&lt;3.1.0,&gt;=3.0.2 in /usr/lib/python2.7/site-packages (from requests&lt;3,&gt;=2.20.0-&gt;docker-compose) (3.0.4)Collecting attrs&gt;=17.4.0 Using cached https://files.pythonhosted.org/packages/a2/db/4313ab3be961f7a763066401fb77f7748373b6094076ae2bda2806988af6/attrs-19.3.0-py2.py3-none-any.whlRequirement already satisfied: setuptools in /usr/lib/python2.7/site-packages/setuptools-19.6.2-py2.7.egg (from jsonschema&lt;4,&gt;=2.5.1-&gt;docker-compose) (19.6.2)Collecting pyrsistent&gt;=0.14.0 Using cached https://files.pythonhosted.org/packages/6c/6f/c1a2e8da80a0029f6b618d7e20e1a6f2a61dd04e2e54225309c2cc4268f7/pyrsistent-0.15.6.tar.gzCollecting importlib-metadata; python_version &lt; “3.8” Using cached https://files.pythonhosted.org/packages/f6/d2/40b3fa882147719744e6aa50ac39cf7a22a913cbcba86a0371176c425a3b/importlib_metadata-0.23-py2.py3-none-any.whlCollecting functools32; python_version &lt; “3” Using cached https://files.pythonhosted.org/packages/c5/60/6ac26ad05857c601308d8fb9e87fa36d0ebf889423f47c3502ef034365db/functools32-3.2.3-2.tar.gzCollecting bcrypt&gt;=3.1.3 Using cached https://files.pythonhosted.org/packages/fa/aa/025a3ab62469b5167bc397837c9ffc486c42a97ef12ceaa6699d8f5a5416/bcrypt-3.1.7.tar.gz Installing build dependencies … done Getting requirements to build wheel … done[colorr]ERROR: Exception:Traceback (most recent call last): File “/usr/lib/python2.7/site-packages/pip/_internal/cli/base_command.py”, line 153, in _main status = self.run(options, args) File “/usr/lib/python2.7/site-packages/pip/_internal/commands/install.py”, line 382, in run resolver.resolve(requirement_set) File “/usr/lib/python2.7/site-packages/pip/_internal/legacy_resolve.py”, line 201, in resolve self._resolve_one(requirement_set, req) File “/usr/lib/python2.7/site-packages/pip/_internal/legacy_resolve.py”, line 365, in _resolve_one abstract_dist = self._get_abstract_dist_for(req_to_install) File “/usr/lib/python2.7/site-packages/pip/_internal/legacy_resolve.py”, line 313, in _get_abstract_dist_for req, self.session, self.finder, self.require_hashes File “/usr/lib/python2.7/site-packages/pip/_internal/operations/prepare.py”, line 224, in prepare_linked_requirement req, self.req_tracker, finder, self.build_isolation, File “/usr/lib/python2.7/site-packages/pip/_internal/operations/prepare.py”, line 49, in _get_prepared_distribution abstract_dist.prepare_distribution_metadata(finder, build_isolation) File “/usr/lib/python2.7/site-packages/pip/_internal/distributions/source/legacy.py”, line 37, in prepare_distribution_metadata self._setup_isolation(finder) File “/usr/lib/python2.7/site-packages/pip/_internal/distributions/source/legacy.py”, line 90, in _setup_isolation reqs = backend.get_requires_for_build_wheel() File “/usr/lib/python2.7/site-packages/pip/_vendor/pep517/wrappers.py”, line 152, in get_requires_for_build_wheel ‘config_settings’: config_settings File “/usr/lib/python2.7/site-packages/pip/_vendor/pep517/wrappers.py”, line 255, in _call_hook raise BackendUnavailable(data.get(‘traceback’, ‘’))BackendUnavailable[/colorr] 解决方案[colory]暂未研究出来解决方案，敬请期待，如果有大神遇过，麻烦留下足迹，谢谢！[/colory] [colorg]经过一番查阅资料终于找到问题的原因了[/colorg] 方式一安装1https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` uname -s = linux uname -m = aarch64 所以这个连接指向的地址是 1https://github.com/docker/compose/releases/download/1.24.1/docker-compose-linux-aarch64 如果你去访问这个地址你会发现 404,所以下载下来的文件根本是错误的，导致安装不上 正确安装方法如下 到https://github.com/docker/compose/releases 中下载对应的版本 这里选择的是 1.23.2 的 docker-compose-Linux-x86_64 /home/download/docker-compose_1.23.2/ 目录 执行一下命令 12345mv /home/download/docker-compose_1.23.2/docker-compose-Linux-x86_64 /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composedocker-compose version 方式二安装 docker ,docker-compose 版本兼容性或者 python2.7的问题，安装太高版本报错所致 直接指定版本号1pip install -U docker-compose==1.23.0","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"docker-compose","slug":"docker-compose","permalink":"https://xxk.link/tags/docker-compose/"}]},{"title":"Golang和其他语言的差异","slug":"category/golang/Golang和其他语言的差异","date":"2019-12-16T03:58:39.000Z","updated":"2021-09-04T05:54:17.000Z","comments":true,"path":"2019/12/16/category/golang/Golang和其他语言的差异/","link":"","permalink":"https://xxk.link/2019/12/16/category/golang/Golang和其他语言的差异/","excerpt":"本文只要讲讲Golang和其他语言的，差异性，让你可以在其他中，可以快速切换到Golang中。Golang吸收了大量语言的特性，有pythone的简单开发，也解决了很多问题，至于为什么选择使用Golang，只要的PHP的局限性太大，JAVA太重。Pythone做数据分析，自己的能力不行。Docker是K8s，K3s都是又golang编写的，搞不好以后可以往架构的方面发展。","text":"本文只要讲讲Golang和其他语言的，差异性，让你可以在其他中，可以快速切换到Golang中。Golang吸收了大量语言的特性，有pythone的简单开发，也解决了很多问题，至于为什么选择使用Golang，只要的PHP的局限性太大，JAVA太重。Pythone做数据分析，自己的能力不行。Docker是K8s，K3s都是又golang编写的，搞不好以后可以往架构的方面发展。 我们先看一下的代码1234567891011121314package main //包，表明代码所在的模块import ( &quot;fmt&quot; &quot;os&quot;) //引入代码依赖包//功能实现func main() &#123; if len(os.Args) &gt; 0 &#123; fmt.Println(&quot;Hello World&quot;,os.Args[0]) &#125; os.Exit(-1)&#125; 可以见的Golang的一个基本组成结构。需要一个package，import和其他语言没有多大区别，还需要一个主运用程序函数func main 我们只需要注意1.必须是main包：package main2.必须是main方法：func main()3.文件名不一定是main.go 很多教程都这么写导致很多人以为这个是必要的入口文件 退出返回值与其他主要的编程语言的差异Go中mian函数不支持任何返回值通过os.Exit来返回状态 获取命令行参数与其他主要的编程语言的差异mian 函数不支持传入参数 比如func main(arg [] string)在程序中直接通过os.Args获取命令行参数 由于为了方便一些代码都用Test的方式来实现。编写测试程序1.源码文件以_test结尾：xxx_test.go2.测试方法名以Test开头:func TestXXX(t *testing.T) {…} 路径为 src/ch2/fib1234567891011121314151617181920212223242526package fibimport ( &quot;testing&quot;)func TestFibList(t *testing.T) &#123; var ( a int = 1 b int = 1 ) t.Log(a) for i := 0; i &lt; 5; i++ &#123; t.Log(&quot; &quot;, b) tmp := a a = b b = a + tmp &#125;&#125;func TestExchange(t *testing.T) &#123; a := 1 b := 2 a, b = b, a t.Log(a, b)&#125; 这里注意的是= 是赋值， := 是声明变量并赋值。12345678910// = 使用必须使用先var声明例如：var aa=100//或var b = 100//或var c int = 100// := 是声明并赋值，并且系统自动推断类型，不需要var关键字d := 100 变量赋值与其他主要的编程语言赋值可以进行自动类型推断在一个赋值语句中可以对多个变量进行同时赋值 常亮定义与其他主要的编程语言快速设置连续值const ( Monday = iota + 1 Tuesday Wednesday) const ( Open = 1 &lt;&lt; iota Close Pending) 数据类型有如下 boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyterun3float32 float64complex64 complex128 Golang的类型转换123456789101112131415161718192021222324252627package type_testimport &quot;testing&quot;type MyInt int64func TestImplicit(t *testing.T) &#123; var a int32 = 1 var b int64 b = int64(a) var c MyInt c = MyInt(b) //go比较严格别名也是不支持 t.Log(a, b, c)&#125;/*指针类型不支持指针运算string时值类型，其默认的初始化值为空字符串，而不是 nil*/func TestPoint(t *testing.T) &#123; a := 1 aPtr := &amp;a t.Log(a, aPtr)&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://xxk.link/categories/golang/"}],"tags":[{"name":"差异","slug":"差异","permalink":"https://xxk.link/tags/差异/"},{"name":"语言","slug":"语言","permalink":"https://xxk.link/tags/语言/"}]},{"title":"java.lang.NoClassDefFoundError: com/blade/Blade","slug":"category/java/java-lang-NoClassDefFoundError-com-blade-Blade","date":"2019-12-13T09:55:04.000Z","updated":"2021-09-04T05:59:03.000Z","comments":true,"path":"2019/12/13/category/java/java-lang-NoClassDefFoundError-com-blade-Blade/","link":"","permalink":"https://xxk.link/2019/12/13/category/java/java-lang-NoClassDefFoundError-com-blade-Blade/","excerpt":"下载了一个 blade 项目进行开发，开发完毕后，上线发现一直报错，查阅资料几乎没有此类问题，最后才发现是打的包不能和平常 springboot 的项目一样，直接使用 idea install,然后 JAVA -jar 执行","text":"下载了一个 blade 项目进行开发，开发完毕后，上线发现一直报错，查阅资料几乎没有此类问题，最后才发现是打的包不能和平常 springboot 的项目一样，直接使用 idea install,然后 JAVA -jar 执行 报错12345678Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/blade/Blade at com.tale.Application.main(Application.java:15)Caused by: java.lang.ClassNotFoundException: com.blade.Blade at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 1 more 解压 jar 包发现文件夹内的文件非常的少，期间尝试将 idea 执行产生的文件直接上传 tomcat，最后也是以失败收尾 解决方案通过对比项目 tale 发现打包方式不一样，然后修改即可 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;descriptors&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/dist/&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.sp.Application&lt;/mainClass&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;/manifest&gt; &lt;manifestEntries&gt; &lt;Class-Path&gt;resources/&lt;/Class-Path&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; assembly.xml[colory]与 pom.xml 同一级[/colory] 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;assembly xmlns=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd&quot;&gt; &lt;id&gt;bin&lt;/id&gt; &lt;formats&gt; &lt;format&gt;tar.gz&lt;/format&gt; &lt;format&gt;zip&lt;/format&gt; &lt;/formats&gt; &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt; &lt;fileSets&gt; &lt;fileSet&gt; &lt;directory&gt;src/main/resources/&lt;/directory&gt; &lt;outputDirectory&gt;/resources&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;fileSet&gt; &lt;directory&gt;src/main/plugins/&lt;/directory&gt; &lt;outputDirectory&gt;/plugins&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;fileSet&gt; &lt;directory&gt;bin/&lt;/directory&gt; &lt;outputDirectory&gt;/&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;/fileSets&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;outputDirectory&gt;/lib&lt;/outputDirectory&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;excludes&gt; &lt;exclude&gt;$&#123;project.groupId&#125;:$&#123;project.artifactId&#125;&lt;/exclude&gt; &lt;/excludes&gt; &lt;/dependencySet&gt; &lt;dependencySet&gt; &lt;outputDirectory&gt;/&lt;/outputDirectory&gt; &lt;includes&gt; &lt;include&gt;$&#123;project.groupId&#125;:$&#123;project.artifactId&#125;&lt;/include&gt; &lt;/includes&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt;&lt;/assembly&gt; 部署 在target 目录下的 dist 文件下有两个文件，解压 tar.gz 文件 执行以下命令1nohup java -jar ***.jar &amp; 到此查看日志 nohup 可以看到启动成功的日志","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"NoClassDefFoundError","slug":"NoClassDefFoundError","permalink":"https://xxk.link/tags/NoClassDefFoundError/"},{"name":"Blade","slug":"Blade","permalink":"https://xxk.link/tags/Blade/"}]},{"title":"@QueryParam Float 接收不到值的问题","slug":"category/java/QueryParam-Float-接收不到值的问题","date":"2019-12-04T09:20:39.000Z","updated":"2021-09-04T06:03:04.000Z","comments":true,"path":"2019/12/04/category/java/QueryParam-Float-接收不到值的问题/","link":"","permalink":"https://xxk.link/2019/12/04/category/java/QueryParam-Float-接收不到值的问题/","excerpt":"从网上下载了一个开源项目，然后发现 bug 太多，发现一个比较奇怪的问题，前端传值已经有值了，后端接收的时候只有一个 Float 的接收不到值","text":"从网上下载了一个开源项目，然后发现 bug 太多，发现一个比较奇怪的问题，前端传值已经有值了，后端接收的时候只有一个 Float 的接收不到值 前端代码123456789101112131415161718192021222324252627282930313233$.ajax(&#123; type: &quot;PUT&quot;, url: &quot;/admin/node/$&#123;node.id&#125;&quot;, dataType: &quot;json&quot;, data: &#123; name: $(&quot;#name&quot;).val(), server: $(&quot;#server&quot;).val(), method: $(&quot;#method&quot;).val(), custom_method: $(&quot;#custom_method&quot;).val(), traffic_rate: $(&quot;#rate&quot;).val(), info: $(&quot;#info&quot;).val(), type: $(&quot;#type&quot;).val(), status: $(&quot;#status&quot;).val(), sort: $(&quot;#sort&quot;).val() &#125;, success: function (data) &#123; if (data.ret) &#123; $(&quot;#msg-error&quot;).hide(100); $(&quot;#msg-success&quot;).show(100); $(&quot;#msg-success-p&quot;).html(data.msg); window.setTimeout(&quot;location.href=&apos;/admin/node&apos;&quot;, 2000); &#125; else &#123; $(&quot;#msg-error&quot;).hide(10); $(&quot;#msg-error&quot;).show(100); $(&quot;#msg-error-p&quot;).html(data.msg); &#125; &#125;, error: function (jqXHR) &#123; $(&quot;#msg-error&quot;).hide(10); $(&quot;#msg-error&quot;).show(100); $(&quot;#msg-error-p&quot;).html(&quot;发生错误：&quot; + jqXHR.status); &#125; &#125;); 后端代码123456789101112131415161718192021222324252627@Route(value = &quot;node/:id&quot;, method = HttpMethod.PUT) @JSON public Result update(@PathParam Integer id, @QueryParam String name, @QueryParam String server, @QueryParam String method, @QueryParam int custom_method, @QueryParam Float traffic_rate, @QueryParam String info, @QueryParam int type, @QueryParam String status, @QueryParam int sort) &#123; Node node = new Node(); node.setId(id); node.setName(name); node.setServer(server); node.setMethod(method); node.setCustom_method(custom_method == 1); node.setTraffic_rate(traffic_rate); node.setInfo(info); node.setType(type); node.setStatus(status); node.setSort(sort); try &#123; nodeService.update(node); &#125; catch (Exception e) &#123; LOGGER.error(&quot;修改节点失败&quot;, e); return Result.fail(&quot;修改失败&quot;); &#125; return Result.ok(&quot;修改成功&quot;); &#125; [colorr]@QueryParam Float traffic_rate 这个值一直都是 null[/colorr] 解决方法[colory]目前还未找到，如果有人找到，欢迎留言！[/colory]","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"Float","slug":"Float","permalink":"https://xxk.link/tags/Float/"},{"name":"QueryParam","slug":"QueryParam","permalink":"https://xxk.link/tags/QueryParam/"}]},{"title":"idea jrebel 热部署搭建","slug":"category/java/idea-jrebel-热部署搭建","date":"2019-12-04T07:21:05.000Z","updated":"2021-09-04T05:58:34.000Z","comments":true,"path":"2019/12/04/category/java/idea-jrebel-热部署搭建/","link":"","permalink":"https://xxk.link/2019/12/04/category/java/idea-jrebel-热部署搭建/","excerpt":"springboot 项目是不是每次改完都需要重新启动，影响效率，于是搭建热部署，不用重启，提高开发效率","text":"springboot 项目是不是每次改完都需要重新启动，影响效率，于是搭建热部署，不用重启，提高开发效率 安装插件jrebel idea 插件市场搜索[colorg]JRebel for IntelliJ[/colorg] [colory]下载安装可能有点慢，重启后直接激活即可，激活不了自行百度[/colory] 组合键 Shift+Ctrl+Alt+/，选择Registry,勾选上compiler.automake.allow.when.app.running Preferences | Build, Execution, Deployment | Compiler,勾选Automatically show first error editor,Build project automatically View | Tool Windows | JRebel ,勾选第一个，此时会在 Resources 目录下创建一个rebel.xml 文件 使用jrebel debug模式重新运行你的项目，更改html或者类的时候，idea就会自动的编译了 总结 如果不行的话，请重复已上步骤试试，特别是第5，还有其它问题，请留言哦！","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://xxk.link/tags/idea/"},{"name":"jrebel","slug":"jrebel","permalink":"https://xxk.link/tags/jrebel/"},{"name":"热部署","slug":"热部署","permalink":"https://xxk.link/tags/热部署/"}]},{"title":"使用Phabricator做为Code Review工具","slug":"category/服务器运维/使用Phabricator做为Code Review工具","date":"2019-11-15T06:41:00.000Z","updated":"2021-09-04T06:20:04.000Z","comments":true,"path":"2019/11/15/category/服务器运维/使用Phabricator做为Code Review工具/","link":"","permalink":"https://xxk.link/2019/11/15/category/服务器运维/使用Phabricator做为Code Review工具/","excerpt":"代码提交不审查是会影响整体的代码质量的，代码在推送到远端仓库的时候会增加一个审查环节，这里使用Phabricator","text":"代码提交不审查是会影响整体的代码质量的，代码在推送到远端仓库的时候会增加一个审查环节，这里使用Phabricator 设置规则 搜索herald 增加一个规则，代码 push 时候进入审查阶段 规则设置 ConditionsWhen [u]all of [/u] these conditions are met:[u]Accepted Differential revision[/u] [u]does not exist[/u][u]仓库[/u] [u]is any of[/u] [u]输入你的仓库名称[/u] 操作Take these actions every time this rule matches:[u]Block push with message[/u] [u]推送消息的内容[/u] 保存后，你提交代码并推送的时候会被阻止，等待审查 客户端安装审查工具查看这篇文章 操作说明[colorr]注意：作者不能审查，需要审查者登录才能审查完毕[/colorr] 审查人，可进行的操作有 Comment：说点什么。可以针对某行代码进行评论，直接点击行号即可 Accept Revision：接受变更，这哥们代码写得不错，不需要改 Request Changes：不行，还要改 Resign as Reviewer：重新指定审查代码的人 Commandeer Revision：字面意思是将这个Revision据为己有的意思，实际上这个时候Reviewer的身份已经变为Owner的身份了，不能再进行Review了，但是Comment还是可以的 Add Reviewer：添加审查人 Add Subscribers：添加订阅者，CC 作者，可进行的操作有 Comment：说点什么。可以针对某行代码进行评论，直接点击行号即可 Abandon Revision：废除版本。废除后，这个版本就不需要再审核了 Plan Changes：计划变更，我自己发现了一些问题或者需求有变，正在改 Add Reviewer：添加其它审查人（除当前审查人外） Add Subscribers：添加订阅者，CC Arcanist - 命令交互 arc diff：发送变更详情和审查请求 arc land：推送变更（Git and Mercurial），当通过审查后使用这个命令 arc list：显示变更处理的情况 arc cover：查找最有可能审查变更的人 arc patch：给版本打补丁 arc export：从Differential下载补丁 arc amend：更新Git commit arc commit：提交变更（SVN） arc branch：查看Git branches更加详细的信息 在配置了 lint 和 unit test intergration后，可以用这些命令 arc lint：静态代码检查 arc unit：单元测试 与其它工具交互 arc upload：上传文件 arc download：下载文件 arc paste：创建和查看剪贴 高级功能 arc call-conduit：执行 Conduit 方法 arc liberate：创建或更新 libphutil 库 arc shell-complete：激活 tab 补全","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"Phabricator","slug":"Phabricator","permalink":"https://xxk.link/tags/Phabricator/"},{"name":"工具","slug":"工具","permalink":"https://xxk.link/tags/工具/"}]},{"title":"关于抽象类和继承","slug":"category/java/关于抽象类和继承","date":"2019-11-15T03:12:33.000Z","updated":"2021-09-04T05:55:41.000Z","comments":true,"path":"2019/11/15/category/java/关于抽象类和继承/","link":"","permalink":"https://xxk.link/2019/11/15/category/java/关于抽象类和继承/","excerpt":"抽象类的继承很常见，但是使用不当就会不知所措了","text":"抽象类的继承很常见，但是使用不当就会不知所措了 语法 抽象方法不能有方法主体 1abstract void xxx(); 抽象类不能被实例化。因为抽象类中方法未具体化，这是一种不完整的类，所以直接实例化也就没有意义了。 抽象类中不一定要包含abstrace方法。也就是了，抽象中可以没有abstract方法。 一旦类中包含了abstract方法，那类该类必须声明为abstract类。 抽象类可以被继承,当继承的父类是抽象类时，需要将抽象类中的所有抽象方法全部实现。 实例抽象类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.jihuiweb.model;import java.io.InputStream;public abstract class TestParentConfig&#123; /** * 获取 App ID * * @return App ID */ abstract String getAppID(); /** * 获取 Mch ID * * @return Mch ID */ abstract String getMchID(); /** * 获取 API 密钥 * * @return API密钥 */ abstract String getKey(); /** * 获取商户证书内容 * * @return 商户证书内容 */ abstract InputStream getCertStream(); /** * HTTP(S) 连接超时时间，单位毫秒 * * @return */ public int getHttpConnectTimeoutMs() &#123; return 6*1000; &#125; /** * HTTP(S) 读数据超时时间，单位毫秒 * * @return */ public int getHttpReadTimeoutMs() &#123; return 8*1000; &#125; /** * 是否自动上报。 * 若要关闭自动上报，子类中实现该函数返回 false 即可。 * * @return */ public boolean shouldAutoReport() &#123; return true; &#125; /** * 进行健康上报的线程的数量 * * @return */ public int getReportWorkerNum() &#123; return 6; &#125; /** * 健康上报缓存消息的最大数量。会有线程去独立上报 * 粗略计算：加入一条消息200B，10000消息占用空间 2000 KB，约为2MB，可以接受 * * @return */ public int getReportQueueMaxSize() &#123; return 10000; &#125; /** * 批量上报，一次最多上报多个数据 * * @return */ public int getReportBatchSize() &#123; return 10; &#125;&#125; 子类，继承抽象类12345678910111213141516171819202122232425262728package com.jihuiweb.model;import java.io.InputStream;public class TestConfig extends TestParentConfig &#123; @Override String getAppID() &#123; return null; &#125; @Override String getMchID() &#123; return null; &#125; @Override String getKey() &#123; return null; &#125; @Override InputStream getCertStream() &#123; return null; &#125;&#125; 进阶 如果父类是 sdk 来的，要从项目种继承它，这种情况，父类默认是[u]protected[/u]类型的，只能在同一个包下才能继承，尝试改成和 sdk 一样的包名！ 总结[colorr]如果这样写还会出现语法编译不通过的情况，建议你查看下你的包是否有问题、冲突等问题[/colorr]","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"抽象类","slug":"抽象类","permalink":"https://xxk.link/tags/抽象类/"},{"name":"继承","slug":"继承","permalink":"https://xxk.link/tags/继承/"}]},{"title":"redis 假死导致内存超过最大长度","slug":"category/服务器运维/redis 假死导致内存超过最大长度","date":"2019-11-13T04:52:00.000Z","updated":"2021-09-04T06:21:57.000Z","comments":true,"path":"2019/11/13/category/服务器运维/redis 假死导致内存超过最大长度/","link":"","permalink":"https://xxk.link/2019/11/13/category/服务器运维/redis 假死导致内存超过最大长度/","excerpt":"调用 redis 经常假死重启才能解决问题","text":"调用 redis 经常假死重启才能解决问题 问题描述查阅日志文件，目录在 redis 的 conf 文件中看 logfile 文件路径即可知道日志目录，查看日志发现包了一个警告 1WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 解决方案[colorr]原因就是因为128太小了[/colorr] 方案1执行echo 511 &gt; /proc/sys/net/core/somaxconn,命令就把这个问题解决了。但是这个只是暂时的。 方案2如果想要永久解决，打开/etc/sysctl.conf，在这里面添net.core.somaxconn= 1024然后执行sysctl -p 就可以永久消除这个warning","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://xxk.link/tags/redis/"},{"name":"内存","slug":"内存","permalink":"https://xxk.link/tags/内存/"}]},{"title":"rap java.lang.OutOfMemoryError: Java heap space","slug":"category/java/rap-java-lang-OutOfMemoryError-Java-heap-space","date":"2019-11-13T04:46:04.000Z","updated":"2021-09-04T06:03:15.000Z","comments":true,"path":"2019/11/13/category/java/rap-java-lang-OutOfMemoryError-Java-heap-space/","link":"","permalink":"https://xxk.link/2019/11/13/category/java/rap-java-lang-OutOfMemoryError-Java-heap-space/","excerpt":"公司接口文档一直使用rap，rap 官方已经不维护了，需要升级到 rap2，由于升级比较麻烦，所以尝试过一次就放弃了，涉及到数据库的迁移等等","text":"公司接口文档一直使用rap，rap 官方已经不维护了，需要升级到 rap2，由于升级比较麻烦，所以尝试过一次就放弃了，涉及到数据库的迁移等等 问题描述 Method checkIn failed for object com.taobao.rigel.rap.workspace.web.action.WorkspaceAction java.lang.OutOfMemoryError: Java heap space 解决方法接口多了情况经常会出现无法保存的问题，查看 log发现是内存溢出导出，经过查阅资料，尝试了很多种方法都不行，最后找到了一种可行方案 首先在 tomcat 的 bin 目录下创建一个文件 setenv.sh 添加下面的内容 123export CATALINA_OPTS=&quot;$CATALINA_OPTS -Xms512m&quot;export CATALINA_OPTS=&quot;$CATALINA_OPTS -Xmx2048m&quot;export CATALINA_OPTS=&quot;$CATALINA_OPTS -XX:MaxPermSize=256m&quot; 3.执行(执行前先杀掉原来的进程) 1./catalina.sh run 通过测试可行，然后退出，使用后台启动即可","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"OutOfMemoryError","slug":"OutOfMemoryError","permalink":"https://xxk.link/tags/OutOfMemoryError/"},{"name":"heap","slug":"heap","permalink":"https://xxk.link/tags/heap/"}]},{"title":"springboot interface not allow null!","slug":"category/java/springboot-interface-not-allow-null","date":"2019-11-13T02:37:32.000Z","updated":"2021-09-04T06:03:38.000Z","comments":true,"path":"2019/11/13/category/java/springboot-interface-not-allow-null/","link":"","permalink":"https://xxk.link/2019/11/13/category/java/springboot-interface-not-allow-null/","excerpt":"测试用例执行的时候报这个错误，项目是 springboot 没有配置文件，检查一遍没发现什么问题，最后跟踪源码调试，发现问题所在","text":"测试用例执行的时候报这个错误，项目是 springboot 没有配置文件，检查一遍没发现什么问题，最后跟踪源码调试，发现问题所在 问题描述 Invocation of init method failed; nested exception is java.lang.IllegalStateException: dubbo:service interface interface not allow null! 1@Service(interfaceClass = TSingleStoreOperationLogServiceImpl.class) 解决方法实现层的注解类写错了，应该是接口而不是实现 1@Service(interfaceClass = ITSingleStoreOperationLogService.class) 总结 这种错误看不出问题所在，不要着急，网上查找资料也是找不到问题所在，唯有通过报错的信息定位到 spring 的源码进行调试，才能定位到你的错误来源，缩小范围，才能快速解决问题！","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://xxk.link/tags/springboot/"}]},{"title":"论算法重要性 递归返回值null","slug":"category/java/论算法重要性-递归返回值null","date":"2019-11-03T01:50:06.000Z","updated":"2021-09-04T05:56:07.000Z","comments":true,"path":"2019/11/03/category/java/论算法重要性-递归返回值null/","link":"","permalink":"https://xxk.link/2019/11/03/category/java/论算法重要性-递归返回值null/","excerpt":"遇到一个树形结构的数据处理，需要用到递归算法，想想也简单，就写呗，经过调试，一旦进入递归返回值就被清空了","text":"遇到一个树形结构的数据处理，需要用到递归算法，想想也简单，就写呗，经过调试，一旦进入递归返回值就被清空了 问题分析1234567891011121314151617181920212223242526272829303132private Map&lt;String,BigDecimal&gt; getAbnormalsLevel(String checkId, Integer itemId,Map&lt;String,BigDecimal&gt; levelMap) &#123; List&lt;String&gt; list = tZhiKangCheckMapper.selectCheckDataByFatherItemId(checkId,itemId); if(list.isEmpty())&#123; //查不到数据 说明没有子节点了; Map&lt;String,Object&gt; result = tZhiKangCheckMapper.selectAbnormalsLevel(checkId,itemId); Assert.notNull(result, &quot;查询异常数据错误&quot;); BigDecimal abnormalsNewCount = new BigDecimal(result.get(&quot;abnormalsCount&quot;).toString()); BigDecimal abnormalsNewLevel = new BigDecimal(result.get(&quot;abnormalsLevel&quot;).toString()); if(levelMap==null)&#123; levelMap = new HashMap&lt;&gt;(); BigDecimal abnormalsCount = BigDecimal.ZERO; BigDecimal abnormalsLevel = BigDecimal.ZERO; levelMap.put(&quot;abnormalsCount&quot;,abnormalsCount); levelMap.put(&quot;abnormalsLevel&quot;,abnormalsLevel); &#125; BigDecimal abnormalsCount = new BigDecimal(levelMap.get(&quot;abnormalsCount&quot;).toString()); BigDecimal abnormalsLevel = new BigDecimal(levelMap.get(&quot;abnormalsLevel&quot;).toString()); levelMap.put(&quot;abnormalsCount&quot;,abnormalsCount.add(abnormalsNewCount)); levelMap.put(&quot;abnormalsLevel&quot;,abnormalsLevel.add(abnormalsNewLevel)); &#125;else&#123; //查到数据递归继续遍历 for(String fatherItemIdStr : list)&#123; Integer fatherItemId = Integer.valueOf(fatherItemIdStr); getAbnormalsLevel(checkId,fatherItemId,levelMap); &#125; &#125; return levelMap; &#125; 当有子节点的时候进入循环递归，进入后levelMap的值就被清空了，没有达到累加效果 解决方法123456789101112131415161718192021222324252627282930313233private Map&lt;String,BigDecimal&gt; getAbnormalsLevel(String checkId, Integer itemId,Map&lt;String,BigDecimal&gt; levelMap) &#123; List&lt;String&gt; list = tZhiKangCheckMapper.selectCheckDataByFatherItemId(checkId,itemId); if(list.isEmpty())&#123; //查不到数据 说明没有子节点了; Map&lt;String,Object&gt; result = tZhiKangCheckMapper.selectAbnormalsLevel(checkId,itemId); Assert.notNull(result, &quot;查询异常数据错误&quot;); BigDecimal abnormalsNewCount = new BigDecimal(result.get(&quot;abnormalsCount&quot;).toString()); BigDecimal abnormalsNewLevel = new BigDecimal(result.get(&quot;abnormalsLevel&quot;).toString()); if(levelMap==null)&#123; levelMap = new HashMap&lt;&gt;(); BigDecimal abnormalsCount = BigDecimal.ZERO; BigDecimal abnormalsLevel = BigDecimal.ZERO; levelMap.put(&quot;abnormalsCount&quot;,abnormalsCount); levelMap.put(&quot;abnormalsLevel&quot;,abnormalsLevel); &#125; BigDecimal abnormalsCount = new BigDecimal(levelMap.get(&quot;abnormalsCount&quot;).toString()); BigDecimal abnormalsLevel = new BigDecimal(levelMap.get(&quot;abnormalsLevel&quot;).toString()); levelMap.put(&quot;abnormalsCount&quot;,abnormalsCount.add(abnormalsNewCount)); levelMap.put(&quot;abnormalsLevel&quot;,abnormalsLevel.add(abnormalsNewLevel)); &#125;else&#123; //查到数据递归继续遍历 for(String fatherItemIdStr : list)&#123; Integer fatherItemId = Integer.valueOf(fatherItemIdStr); levelMap = getAbnormalsLevel(checkId,fatherItemId,levelMap); &#125; &#125; return levelMap; &#125; [u]将递归后的值重新赋给返回值即可，就这么个小毛病折腾了好久[/u] 1levelMap = getAbnormalsLevel(checkId,fatherItemId,levelMap);","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xxk.link/tags/算法/"},{"name":"递归","slug":"递归","permalink":"https://xxk.link/tags/递归/"}]},{"title":"lombok简化java 代码提高效率","slug":"category/java/lombok简化java-代码提高效率","date":"2019-10-30T01:12:32.000Z","updated":"2021-09-04T05:59:24.000Z","comments":true,"path":"2019/10/30/category/java/lombok简化java-代码提高效率/","link":"","permalink":"https://xxk.link/2019/10/30/category/java/lombok简化java-代码提高效率/","excerpt":"今天 github 看了一个项目代码，发现运行没有问题，但是idea 一直报错，实体没有生成对应的 get,set方法，这里很疑惑，它究竟是怎么运行起来的呢？然后发现它的实体有个@Data 的注解，然后查阅资料才发现是一个插件lombok简化了代码","text":"今天 github 看了一个项目代码，发现运行没有问题，但是idea 一直报错，实体没有生成对应的 get,set方法，这里很疑惑，它究竟是怎么运行起来的呢？然后发现它的实体有个@Data 的注解，然后查阅资料才发现是一个插件lombok简化了代码 使用 idea 的时候会报错，应该安装lombok插件 1234567891011121314package com.lombok; import lombok.Data; import lombok.EqualsAndHashCode; import java.util.List; @Data public class Student &#123; String name; int sex; Integer age; String address; List&lt;String&gt; books; &#125; lombok 注解 @Data ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、 hashCode、toString 方法 @Setter：注解在属性上；为属性提供 setting 方法 @Getter：注解在属性上；为属性提供 getting 方法 @Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象 @NoArgsConstructor：注解在类上；为类提供一个无参的构造方法 @AllArgsConstructor：注解在类上；为类提供一个全参的构造方法 原理分析自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”规范，只要程序实现了该API，就能在javac运行的时候得到调用。 lombok本质上就是这样的一个实现了”JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下： javac对源代码进行分析，生成一棵抽象语法树(AST) 运行过程中调用实现了”JSR 269 API”的lombok程序 此时lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树(AST)，然后修改该语法树(AST)，增加getter和setter方法定义的相应树节点 javac使用修改后的抽象语法树(AST)生成字节码文件 lombok 优缺点优点 能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率 让代码变得简洁，不用过多的去关注相应的方法属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等 缺点 不支持多种参数构造器的重载 虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度 总结知乎上有位大神发表过对Lombok的一些看法 这是一种低级趣味的插件，不建议使用。JAVA发展到今天，各种插件层出不穷，如何甄别各种插件的优劣？能从架构上优化你的设计的，能提高应用程序性能的 ，实现高度封装可扩展的…， 像lombok这种，像这种插件，已经不仅仅是插件了，改变了你如何编写源码，事实上，少去了代码你写上去又如何？如果JAVA家族到处充斥这样的东西，那只不过是一坨披着金属颜色的屎，迟早会被其它的语言取代。 虽然话糙但理确实不糙，试想一个项目有非常多类似Lombok这样的插件，个人觉得真的会极大的降低阅读源代码的舒适度。","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"lombok","slug":"lombok","permalink":"https://xxk.link/tags/lombok/"},{"name":"效率","slug":"效率","permalink":"https://xxk.link/tags/效率/"}]},{"title":"小程序 输出警告","slug":"category/小程序/小程序-输出警告","date":"2019-10-30T01:10:00.000Z","updated":"2021-09-04T05:52:59.000Z","comments":true,"path":"2019/10/30/category/小程序/小程序-输出警告/","link":"","permalink":"https://xxk.link/2019/10/30/category/小程序/小程序-输出警告/","excerpt":"小程序 输出警告 Now you can provide attr wx:key for a wx:for to improve performance","text":"小程序 输出警告 Now you can provide attr wx:key for a wx:for to improve performance 解决方法12&lt;view class='physiology' wx:for='&#123;&#123;messageList&#125;&#125;' wx:key=\"key\" wx:for-item=\"items\" wx:for-key=\"index\"&gt;&lt;/view&gt;","categories":[{"name":"小程序","slug":"小程序","permalink":"https://xxk.link/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://xxk.link/tags/小程序/"},{"name":"警告","slug":"警告","permalink":"https://xxk.link/tags/警告/"}]},{"title":"小程序 boundingClientRect rect 为 null","slug":"category/小程序/小程序-boundingClientRect-rect-为-null","date":"2019-10-30T01:09:28.000Z","updated":"2021-09-04T05:53:48.000Z","comments":true,"path":"2019/10/30/category/小程序/小程序-boundingClientRect-rect-为-null/","link":"","permalink":"https://xxk.link/2019/10/30/category/小程序/小程序-boundingClientRect-rect-为-null/","excerpt":"页面内定位到具体的位置，使用id的值进行查找来实现，结果出现rect为 null情况","text":"页面内定位到具体的位置，使用id的值进行查找来实现，结果出现rect为 null情况 代码如下123456789101112131415changeId: function (e) &#123;//监听页面滚动 console.log(e) let id = e.currentTarget.dataset.opd; this.setData(&#123; toView: id, &#125;); console.log(\"----toView:\" + this.data.toView); wx.createSelectorQuery().select('#' + this.data.toView).boundingClientRect(function (rect) &#123; console.log(\"----rect:\" + rect); wx.pageScrollTo(&#123; scrollTop: rect.top, duration: 300 &#125;) &#125;).exec() &#125; 原因分析++id首位不能是数字，要不然小程序获取不到相关信息++ 解决方法1&lt;view class='physiology_text' id='slide&#123;&#123;items.id&#125;&#125;'&gt;&lt;/view&gt; id 前增加字母即可","categories":[{"name":"小程序","slug":"小程序","permalink":"https://xxk.link/categories/小程序/"}],"tags":[{"name":"boundingClientRect","slug":"boundingClientRect","permalink":"https://xxk.link/tags/boundingClientRect/"}]},{"title":"微信小程序开发-服务端sessionid不一样","slug":"category/小程序/微信小程序开发-服务端sessionid不一样","date":"2019-10-30T01:09:04.000Z","updated":"2021-09-04T05:53:27.000Z","comments":true,"path":"2019/10/30/category/小程序/微信小程序开发-服务端sessionid不一样/","link":"","permalink":"https://xxk.link/2019/10/30/category/小程序/微信小程序开发-服务端sessionid不一样/","excerpt":"不管是哪种语言，需要保存会话状态的，服务端的会在response的header中加上Set-Cookie，无状态通过 token 的除外","text":"不管是哪种语言，需要保存会话状态的，服务端的会在response的header中加上Set-Cookie，无状态通过 token 的除外 查看token 1234Response HeadersContent-Type:application/json;charset=UTF-8Date:Mon, 02 Apr 2018 16:02:42 GMTSet-Cookie:JSESSIONID=781C7F500DFA24D663BA243A4D9044BC;path=/yht;HttpOnly 通过查看浏览器的请求header中信息 123456789Request HeadersAccept:*/*Accept-Encoding:gzip, deflate, brAccept-Language:zh-CN,zh;q=0.8Cache-Control:no-cacheConnection:keep-aliveContent-Length:564content-type:application/jsonCookie:JSESSIONID=781C7F500DFA24D663BA243A4D9044BC;path=/yht;HttpOnly 通过这个sessionid就能使浏览器端和服务端保持会话，使浏览器端保持登录状态 但是，微信小程序不能保存Cookie，导致每次wx.request到服务端都会创建一个新的会话，小程序端就不能保持登录状态了 最较简单的办法就是在小程序端把cookie保存到storage里，后续请求的时候再读storage，把cookie添加到请求头里，这样做的好处就是，服务端不用做任何改动 具体操作如下： 把服务端response的Set-Cookie中的值保存到Storage中 123456789101112wx.request(&#123; url: path, method:method, header: header, data:data, success:function(res)&#123; if(res &amp;&amp; res.header &amp;&amp; res.header['Set-Cookie'])&#123; wx.setStorageSync('cookieKey', res.header['Set-Cookie']);//保存Cookie到Storage &#125;&#125;, fail:fail &#125;) 小程序wx.request再从Storage中取出Cookie,封装到header中 123456789101112131415let cookie = wx.getStorageSync('cookieKey');let path=conf.baseurl+url;let header = &#123; &#125;;if(cookie)&#123; header.Cookie=cookie;&#125;wx.request(&#123; url: path, method:method, header: header, data:data, success:success, fail:fail&#125;)","categories":[{"name":"小程序","slug":"小程序","permalink":"https://xxk.link/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://xxk.link/tags/小程序/"},{"name":"sessionid","slug":"sessionid","permalink":"https://xxk.link/tags/sessionid/"}]},{"title":"flarum facebook 登录授权地址失败","slug":"category/服务器运维/flarum facebook 登录授权地址失败","date":"2019-10-29T18:50:00.000Z","updated":"2021-09-04T06:23:42.000Z","comments":true,"path":"2019/10/30/category/服务器运维/flarum facebook 登录授权地址失败/","link":"","permalink":"https://xxk.link/2019/10/30/category/服务器运维/flarum facebook 登录授权地址失败/","excerpt":"网址被禁，跳转失败，原因是跳转 URI 未加入 OAuth 客户端授权设置白名单。请确保客户端和网页的 OAuth 授权登录功能已开启，并把所有应用域添加为有效 OAuth 跳转 URI。","text":"网址被禁，跳转失败，原因是跳转 URI 未加入 OAuth 客户端授权设置白名单。请确保客户端和网页的 OAuth 授权登录功能已开启，并把所有应用域添加为有效 OAuth 跳转 URI。 问题分析1.前往 facebook 开发者平台(地址[colort]https://developers.facebook.com[/colort]) 开通登录授权2.跳转 url 授权校验和网上查资料有效 OAuth 跳转 URI应该填[colorg]https://b.jihuiweb.com/auth/facebook/callback[/colorg]3.为何 flarum 点击登录的时候出现失败，最后发现点击登录跳转的地址是[colorb]https://b.jihuiweb.com/auth/facebook[/colorb] 解决方案1.前端跳转地址修改 文件地址 [colorr]flarum/vendor/flarum/flarum-ext-auth-facebook/js/forum/dist/extension.js[/colorr]文件地址 [colorr]flarum/vendor/flarum/flarum-ext-auth-facebook/js/forum/src/main.js[/colorr] path=”/auth/facebook”修改为path=”/auth/facebook/callback” 2.后端请求接口地址修改文件地址[colorr]flarum/vendor/flarum/flarum-ext-auth-facebook/src/Listener/AddFacebookAuthRoute.php[/colorr] $event-&gt;get(‘/auth/facebook’, ‘auth.facebook’, ‘Flarum\\Auth\\Facebook\\FacebookAuthController’);修改为$event-&gt;get(‘/auth/facebook/callback’, ‘auth.facebook’, ‘Flarum\\Auth\\Facebook\\FacebookAuthController’); 测试后问题解决","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"flarum","slug":"flarum","permalink":"https://xxk.link/tags/flarum/"},{"name":"授权","slug":"授权","permalink":"https://xxk.link/tags/授权/"}]},{"title":"mybatis sql 需要注意的问题","slug":"category/java/mybatis-sql-problem","date":"2018-12-29T08:46:00.000Z","updated":"2021-09-04T06:03:50.000Z","comments":true,"path":"2018/12/29/category/java/mybatis-sql-problem/","link":"","permalink":"https://xxk.link/2018/12/29/category/java/mybatis-sql-problem/","excerpt":"mybatis 的映射、数据类型、返回类型以及传参等很容易出现问题，本人总结了下比较容易出现问题的地方以及解决方案","text":"mybatis 的映射、数据类型、返回类型以及传参等很容易出现问题，本人总结了下比较容易出现问题的地方以及解决方案 传入参数123&lt;select id=\"selectList\" resultMap=\"BaseResultMap\" parameterType=\"map\"&gt; &lt;/select&gt; 像这种定义了参数类型的格式，那么dao 里的定义参数的时候必须传入 map 对应 123&lt;select id=\"selectList\" resultMap=\"BaseResultMap\"&gt; &lt;/select&gt; 像这种没有定义了参数类型的格式，那么dao 里的定义参数的时候必须定义 params() 与之对应 1List&lt;Map&lt;String, Object&gt;&gt; getUserInfo(@Param(\"userId\") String userId); 问题1 参数传0的情况无效 123&lt;if test=\"status != null and status !=''\"&gt; AND status = #&#123;status&#125;&lt;/if&gt; 搜索过滤类型或状态的时候，定义了0的情况，则会无效 123&lt;if test=\"status != null and status !='' or status==0\"&gt; AND status = #&#123;status&#125;&lt;/if&gt; 问题2 参数是Date 类型传进来的时候 123&lt;if test=\"strTime != null and strTime !=''\"&gt; AND bill_time &lt; #&#123;strTime&#125;&lt;/if&gt; mybatis 会报错类型不匹配 需要删掉 空字符的判断即可 或者参数以字符串类型传过来 123&lt;if test=\"strTime != null\"&gt; AND bill_time &lt; #&#123;strTime&#125;&lt;/if&gt; 返回结果12345678910111213&lt;select id=\"selectList\" resultMap=\"BaseResultMap\"&gt; SELECT a.* FROM t_base_life_record a WHERE a.custom_id = #&#123;customId&#125; ORDER BY a.create_time DESC&lt;/select&gt;&lt;resultMap id=\"BaseResultMap\" type=\"com.company.report.dao.model.TBaseRecord\"&gt; &lt;result column=\"life_time\" jdbcType=\"VARCHAR\" property=\"lifeTime\"/&gt; &lt;result column=\"life_date\" jdbcType=\"VARCHAR\" property=\"lifeDate\"/&gt; &lt;result column=\"measure\" jdbcType=\"INTEGER\" property=\"measure\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"custom_id\" jdbcType=\"VARCHAR\" property=\"customId\"/&gt;&lt;/resultMap&gt; 像这种定义了resultMap格式，那么必须要在mapper定于与之对应,column 必须与之sql 查询字段名对应 123456&lt;select id=\"selectList\" resultType=\"com.company.report.dao.model.TBaseRecord\"&gt; SELECT a.* FROM t_base_life_record a WHERE a.custom_id = #&#123;customId&#125; ORDER BY a.create_time DESC&lt;/select&gt; 像这种定义了resultType格式，那么必须model 与之sql 查询字段名对应，多表查询的时候是增加字段的时候必须 model 要增加字段，比较麻烦不推荐 [推荐]比较灵活123456&lt;select id=\"selectList\" resultType=\"map\"&gt; SELECT a.* FROM t_base_life_record a WHERE a.custom_id = #&#123;customId&#125; ORDER BY a.create_time DESC&lt;/select&gt; 一时想不到其它场景问题，到时有持续更新,如有错误之处请指正……","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://xxk.link/tags/mybatis/"},{"name":"sql","slug":"sql","permalink":"https://xxk.link/tags/sql/"}]},{"title":"生成自定义小程序二维码","slug":"category/java/生成自定义小程序二维码","date":"2018-06-16T00:52:05.000Z","updated":"2021-09-04T05:56:52.000Z","comments":true,"path":"2018/06/16/category/java/生成自定义小程序二维码/","link":"","permalink":"https://xxk.link/2018/06/16/category/java/生成自定义小程序二维码/","excerpt":"通过微信小程序官方接口生成的二维码中的logo是我们小程序的官方logo,那么我要生成用户的小程序二维码的话，则需要将logo换成用户头像，微信官方有提供接口吗？(我是没有找到，如果你找到了请留言！)","text":"通过微信小程序官方接口生成的二维码中的logo是我们小程序的官方logo,那么我要生成用户的小程序二维码的话，则需要将logo换成用户头像，微信官方有提供接口吗？(我是没有找到，如果你找到了请留言！) 思路 可以通过解析微信官方的二维码，获取二维码信息，然后我们重新生成带logo的二维码。 根据官方的二维码，将用户的logo画图进去。 推荐使用第一种 代码示例引用jar包12345&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt;&lt;/dependency&gt; 引用二维码工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import java.awt.Graphics2D;import java.awt.geom.AffineTransform;import java.awt.image.BufferedImage;import com.google.zxing.LuminanceSource;/** * LuminanceSource这类层次结构的目的是不同的位图实现跨平台为请求获得灰度亮度值的标准接口。该接口只提供了抽象方法， * 因此可以生成和旋转创建副本。这是为了确保一个读者不修改原来的亮度源，并让它在一个未知的状态，在链中的其他读者。 * https://zxing.github.io/zxing/apidocs/com/google/zxing/LuminanceSource.html * @author ljheee * */public class BufferedImageLuminanceSource extends LuminanceSource &#123; private final BufferedImage image; private final int left; private final int top; public BufferedImageLuminanceSource(BufferedImage image) &#123; this(image, 0, 0, image.getWidth(), image.getHeight()); &#125; /** * 构造方法 * @param image * @param left * @param top * @param width * @param height */ public BufferedImageLuminanceSource(BufferedImage image, int left, int top, int width, int height) &#123; super(width, height); int sourceWidth = image.getWidth(); int sourceHeight = image.getHeight(); if (left + width &gt; sourceWidth || top + height &gt; sourceHeight) &#123; throw new IllegalArgumentException(&quot;Crop rectangle does not fit within image data.&quot;); &#125; for (int y = top; y &lt; top + height; y++) &#123; for (int x = left; x &lt; left + width; x++) &#123; if ((image.getRGB(x, y) &amp; 0xFF000000) == 0) &#123; image.setRGB(x, y, 0xFFFFFFFF); // = white &#125; &#125; &#125; this.image = new BufferedImage(sourceWidth, sourceHeight, BufferedImage.TYPE_BYTE_GRAY); this.image.getGraphics().drawImage(image, 0, 0, null); this.left = left; this.top = top; &#125; @Override public byte[] getRow(int y, byte[] row) &#123;//从底层平台的位图提取一行（only one row）的亮度数据值 if (y &lt; 0 || y &gt;= getHeight()) &#123; throw new IllegalArgumentException(&quot;Requested row is outside the image: &quot; + y); &#125; int width = getWidth(); if (row == null || row.length &lt; width) &#123; row = new byte[width]; &#125; image.getRaster().getDataElements(left, top + y, width, 1, row); return row; &#125; @Override public byte[] getMatrix() &#123;///从底层平台的位图提取亮度数据值 int width = getWidth(); int height = getHeight(); int area = width * height; byte[] matrix = new byte[area]; image.getRaster().getDataElements(left, top, width, height, matrix); return matrix; &#125; @Override public boolean isCropSupported() &#123;//是否支持裁剪 return true; &#125; /** * 返回一个新的对象与裁剪的图像数据。实现可以保存对原始数据的引用，而不是复制。 */ @Override public LuminanceSource crop(int left, int top, int width, int height) &#123; return new BufferedImageLuminanceSource(image, this.left + left, this.top + top, width, height); &#125; @Override public boolean isRotateSupported() &#123;//是否支持旋转 return true; &#125; @Override public LuminanceSource rotateCounterClockwise() &#123;//逆时针旋转图像数据的90度，返回一个新的对象。 int sourceWidth = image.getWidth(); int sourceHeight = image.getHeight(); AffineTransform transform = new AffineTransform(0.0, -1.0, 1.0, 0.0, 0.0, sourceWidth); BufferedImage rotatedImage = new BufferedImage(sourceHeight, sourceWidth, BufferedImage.TYPE_BYTE_GRAY); Graphics2D g = rotatedImage.createGraphics(); g.drawImage(image, transform, null); g.dispose(); int width = getWidth(); return new BufferedImageLuminanceSource(rotatedImage, top, sourceWidth - (left + width), getHeight(), width); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.awt.BasicStroke;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Image;import java.awt.Shape;import java.awt.geom.RoundRectangle2D;import java.io.*;import java.net.URL;import java.util.Hashtable;import java.util.Random;import com.google.zxing.BarcodeFormat;import com.google.zxing.BinaryBitmap;import com.google.zxing.DecodeHintType;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatReader;import com.google.zxing.MultiFormatWriter;import com.google.zxing.Result;import com.google.zxing.common.BitMatrix;import com.google.zxing.common.HybridBinarizer;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;import com.w.wanbo.nightclub_wxcomm.utils.UploadImageUtil;/** * 二维码生成工具 * @author ljheee * */public class QRCodeUtil &#123; private static final String CHARSET = &quot;utf-8&quot;; private static final String FORMAT_NAME = &quot;JPG&quot;; // 二维码尺寸 private static final int QRCODE_SIZE = 300; // LOGO宽度 private static final int WIDTH = 60; // LOGO高度 private static final int HEIGHT = 60; /** * 生成二维码 * @param content 源内容 * @param imgPath 生成二维码保存的路径 * @param needCompress 是否要压缩 * @return 返回二维码图片 * @throws Exception */ private static BufferedImage createImage(String content, String imgPath, boolean needCompress) throws Exception &#123; Hashtable hints = new Hashtable(); hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); hints.put(EncodeHintType.CHARACTER_SET, CHARSET); hints.put(EncodeHintType.MARGIN, 1); BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, QRCODE_SIZE, QRCODE_SIZE, hints); int width = bitMatrix.getWidth(); int height = bitMatrix.getHeight(); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; width; x++) &#123; for (int y = 0; y &lt; height; y++) &#123; image.setRGB(x, y, bitMatrix.get(x, y) ? 0xFF000000 : 0xFFFFFFFF); &#125; &#125; if (imgPath == null || &quot;&quot;.equals(imgPath)) &#123; return image; &#125; // 插入图片 QRCodeUtil.insertImageUrl(image, imgPath, needCompress); return image; &#125; /** * 在生成的二维码中插入图片 * @param source * @param imgPath * @param needCompress * @throws Exception */ private static void insertImage(BufferedImage source, String imgPath, boolean needCompress) throws Exception &#123; File file = new File(imgPath); if (!file.exists()) &#123; System.err.println(&quot;&quot; + imgPath + &quot; 该文件不存在！&quot;); return; &#125; Image src = ImageIO.read(new File(imgPath)); int width = src.getWidth(null); int height = src.getHeight(null); if (needCompress) &#123; // 压缩LOGO if (width &gt; WIDTH) &#123; width = WIDTH; &#125; if (height &gt; HEIGHT) &#123; height = HEIGHT; &#125; Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH); BufferedImage tag = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = tag.getGraphics(); g.drawImage(image, 0, 0, null); // 绘制缩小后的图 g.dispose(); src = image; &#125; // 插入LOGO Graphics2D graph = source.createGraphics(); int x = (QRCODE_SIZE - width) / 2; int y = (QRCODE_SIZE - height) / 2; graph.drawImage(src, x, y, width, height, null); Shape shape = new RoundRectangle2D.Float(x, y, width, width, 6, 6); graph.setStroke(new BasicStroke(3f)); graph.draw(shape); graph.dispose(); &#125; private static void insertImageUrl(BufferedImage source, String imgPath, boolean needCompress) throws Exception &#123; URL url = new URL(imgPath); Image src = ImageIO.read(url); int width = src.getWidth(null); int height = src.getHeight(null); if (needCompress) &#123; // 压缩LOGO if (width &gt; WIDTH) &#123; width = WIDTH; &#125; if (height &gt; HEIGHT) &#123; height = HEIGHT; &#125; Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH); BufferedImage tag = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = tag.getGraphics(); g.drawImage(image, 0, 0, null); // 绘制缩小后的图 g.dispose(); src = image; &#125; // 插入LOGO Graphics2D graph = source.createGraphics(); int x = (QRCODE_SIZE - width) / 2; int y = (QRCODE_SIZE - height) / 2; graph.drawImage(src, x, y, width, height, null); Shape shape = new RoundRectangle2D.Float(x, y, width, width, 6, 6); graph.setStroke(new BasicStroke(3f)); graph.draw(shape); graph.dispose(); &#125; /** * 生成带logo二维码，并保存到磁盘 * @param content * @param imgPath logo图片 * @param destPath * @param needCompress * @throws Exception */ public static void encode(String content, String imgPath, String destPath, boolean needCompress) throws Exception &#123; BufferedImage image = QRCodeUtil.createImage(content, imgPath, needCompress); mkdirs(destPath); String file = new Random().nextInt(99999999) + &quot;.jpg&quot;;//生成随机文件名 ImageIO.write(image, FORMAT_NAME, new File(destPath + &quot;/&quot; + file)); &#125; public static String createQrcode(String content, String imgPath, boolean needCompress) throws Exception &#123; BufferedImage image = QRCodeUtil.createImage(content, imgPath, needCompress); ByteArrayOutputStream os = new ByteArrayOutputStream(); ImageIO.write(image, &quot;png&quot;, os); InputStream inputStream = new ByteArrayInputStream(os.toByteArray()); String qrcodeUrl = UploadImageUtil.uploadImage(inputStream); return qrcodeUrl; &#125; public static void mkdirs(String destPath) &#123; File file = new File(destPath); // 当文件夹不存在时，mkdirs会自动创建多层目录，区别于mkdir。(mkdir如果父目录不存在则会抛出异常) if (!file.exists() &amp;&amp; !file.isDirectory()) &#123; file.mkdirs(); &#125; &#125; public static void encode(String content, String imgPath, String destPath) throws Exception &#123; QRCodeUtil.encode(content, imgPath, destPath, false); &#125; public static void encode(String content, String destPath, boolean needCompress) throws Exception &#123; QRCodeUtil.encode(content, null, destPath, needCompress); &#125; public static void encode(String content, String destPath) throws Exception &#123; QRCodeUtil.encode(content, null, destPath, false); &#125; public static void encode(String content, String imgPath, OutputStream output, boolean needCompress) throws Exception &#123; BufferedImage image = QRCodeUtil.createImage(content, imgPath, needCompress); ImageIO.write(image, FORMAT_NAME, output); &#125; public static void encode(String content, OutputStream output) throws Exception &#123; QRCodeUtil.encode(content, null, output, false); &#125; /** * 从二维码中，解析数据 * @param file 二维码图片文件 * @return 返回从二维码中解析到的数据值 * @throws Exception */ public static String decode(File file) throws Exception &#123; BufferedImage image; image = ImageIO.read(file); if (image == null) &#123; return null; &#125; BufferedImageLuminanceSource source = new BufferedImageLuminanceSource(image); BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); Result result; Hashtable hints = new Hashtable(); hints.put(DecodeHintType.CHARACTER_SET, CHARSET); result = new MultiFormatReader().decode(bitmap, hints); String resultStr = result.getText(); return resultStr; &#125; /** * 从二维码中，解析数据 * @param file 二维码图片文件 * @return 返回从二维码中解析到的数据值 * @throws Exception */ public static String decode(String qrcodeUrl) throws Exception &#123; URL url = new URL(qrcodeUrl); BufferedImage image; image = ImageIO.read(url); if (image == null) &#123; return null; &#125; BufferedImageLuminanceSource source = new BufferedImageLuminanceSource(image); BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); Result result; Hashtable hints = new Hashtable(); hints.put(DecodeHintType.CHARACTER_SET, CHARSET); result = new MultiFormatReader().decode(bitmap, hints); String resultStr = result.getText(); return resultStr; &#125;// public static String decode(String path) throws Exception &#123;// return QRCodeUtil.decode(new File(path));// &#125;&#125; 代码123String qrcodeContent = QRCodeUtil.decode(&apos;官方生成的二维码地址&apos;);//生成二维码String qrcodeData = QRCodeUtil.createQrcode(qrcodeContent,&apos;用户头像&apos;,true); 二维码地址是采用七牛云的网络地址，你也可以使用本地文件","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"二维码","slug":"二维码","permalink":"https://xxk.link/tags/二维码/"},{"name":"小程序","slug":"小程序","permalink":"https://xxk.link/tags/小程序/"}]},{"title":"生成二维码并下载","slug":"category/java/生成二维码并下载","date":"2018-05-21T06:05:34.000Z","updated":"2021-09-04T05:56:27.000Z","comments":true,"path":"2018/05/21/category/java/生成二维码并下载/","link":"","permalink":"https://xxk.link/2018/05/21/category/java/生成二维码并下载/","excerpt":"公司有个需求需要生成，下载二维码，供扫码快速完成操作。","text":"公司有个需求需要生成，下载二维码，供扫码快速完成操作。 主要代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * 生成，下载二维码 * * @param aoData * @return */ @RequestMapping(&quot;load&quot;) public void load(String fromWhere, String url, HttpServletResponse response, HttpServletRequest request, HttpSession session) throws IOException &#123; BufferedInputStream dis = null; BufferedOutputStream fos = null; try &#123; UUID uuid = UUID.randomUUID(); //response.setContentType(&quot;application/x-msdownload;&quot;); String fileName = uuid+&quot;.jpg&quot;; String content = url + &quot;?fromWhere=&quot; + fromWhere; //获取文件的路径 String ccbPath = session.getServletContext().getRealPath(&quot;/&quot;) + &quot;assets/images/logo.png&quot; ; System.out.println(ccbPath); InputStream qrcode = EncoderHandler.encoderQRCoder(content, ccbPath); response.setContentType(&quot;image/png&quot;); response.setHeader(&quot;Content-disposition&quot;, &quot;attachment; filename=&quot; + new String(fileName.getBytes(&quot;utf-8&quot;), &quot;ISO8859-1&quot;)); byte[] byt = new byte[qrcode.available()]; response.setHeader(&quot;Content-Length&quot;, String.valueOf(byt.length)); dis = new BufferedInputStream(qrcode); fos = new BufferedOutputStream(response.getOutputStream()); byte[] buff = new byte[2048]; int bytesRead; while (-1 != (bytesRead = dis.read(buff, 0, buff.length))) &#123; fos.write(buff, 0, bytesRead); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (dis != null) dis.close(); if (fos != null) fos.close(); &#125; &#125; 生成二维码类和jar包下载[upl-file uuid=9ee7b502-44cc-4612-bb78-f128a3119625 size=1MB]qrcode-tools.zip[/upl-file]","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"二维码","slug":"二维码","permalink":"https://xxk.link/tags/二维码/"},{"name":"下载","slug":"下载","permalink":"https://xxk.link/tags/下载/"}]},{"title":"安装php Error","slug":"category/服务器运维/安装php Error","date":"2018-05-14T06:27:00.000Z","updated":"2021-09-04T06:25:38.000Z","comments":true,"path":"2018/05/14/category/服务器运维/安装php Error/","link":"","permalink":"https://xxk.link/2018/05/14/category/服务器运维/安装php Error/","excerpt":"php71w-common conflicts with php-common-5.4.16-43.el7_4.1.x86_64,这个问题困惑许久，查找资料，大部分都说指定安装的版本即可解决，本人亲测无用","text":"php71w-common conflicts with php-common-5.4.16-43.el7_4.1.x86_64,这个问题困惑许久，查找资料，大部分都说指定安装的版本即可解决，本人亲测无用 配置yum源12rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装1yum -y install php71w-devel php71w-fpm 这一步就报错了123Error: php71w-common conflicts with php-common-5.4.16-43.el7_4.1.x86_64 You could try using --skip-broken to work around the problem You could try running: rpm -Va --nofiles --nodigest 解决方法1yum remove php-common-5.4.16-43.el7_4.1.x86_64 一行代码直接解决 php版本查看1234 php -vPHP 7.1.16 (cli) (built: Mar 30 2018 07:40:43) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies 查看php拓展1234567891011121314151617181920212223242526272829303132333435php -m[PHP Modules]bz2calendarCorectypecurldateexiffileinfofilterftpgettextgmphashiconvjsonlibxmlopensslpcntlpcrePharreadlineReflectionsessionshmopSimpleXMLsocketsSPLstandardtokenizerxmlzipzlib[Zend Modules] 启动php-fpm1systemctl start php-fpm.service pecl安装php拓展1.安装pecl123456789101112131415161718192021222324252627282930# curl -o go-pear.php http://pear.php.net/go-pear.phar# php go-pear.php//查看pecl是否安装成功#pecl -VWarning: Invalid argument supplied for foreach() in Command.php on line 249Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249Warning: Invalid argument supplied for foreach() in Command.php on line 249Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249Warning: Invalid argument supplied for foreach() in Command.php on line 249Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249Warning: Invalid argument supplied for foreach() in Command.php on line 249...//解决办法#vim /usr/bin/pecl//找到下面这句---------------------------------------------------------------------------------------------------------------------------------------------exec $PHP -C -n -q $INCARG -d date.timezone=UTC -d output_buffering=1 -d variables_order=EGPCS -d safe_mode=0 -d register_argc_argv=&quot;On&quot; $INCDIR/peclcmd.php &quot;$@&quot;---------------------------------------------------------------------------------------------------------------------------------------------//去掉-n# pecl -VPEAR Version: 1.10.5PHP Version: 7.1.8Zend Engine Version: 3.1.0Running on: Linux localhost.localdomain 3.10.0-693.2.2.el7.x86_64 #1 SMP Tue Sep 12 22:26:13 UTC 2017 x86_64 2.安装mongodb12345pecl install mongodb//编译的时候很可能会报错error：Cannot find OpenSSL&apos;s &lt;evp.h&gt;//解决办法yum -y install openssl-devel openssl pkgconfig 最后修改配置文件php.ini ，添加一句1extension=mongodb.so php.ini 默认路径在/etc/php.ini","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"php","slug":"php","permalink":"https://xxk.link/tags/php/"},{"name":"error","slug":"error","permalink":"https://xxk.link/tags/error/"}]},{"title":"centos nginx源码安装","slug":"category/服务器运维/centos nginx源码安装","date":"2018-05-14T06:20:00.000Z","updated":"2021-09-04T06:27:19.000Z","comments":true,"path":"2018/05/14/category/服务器运维/centos nginx源码安装/","link":"","permalink":"https://xxk.link/2018/05/14/category/服务器运维/centos nginx源码安装/","excerpt":"centos最简单安装nginx的方法","text":"centos最简单安装nginx的方法 下载nginx源码包下载地址 检查安装依赖项 执行下面的命令安装nginx的依赖库1yum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel 安装1.创建一个安装目录1mkdir /usr/local/nginx 2.配置到安装目录1./configure --prefix=/usr/local/nginx --sbin-path=/usr/bin/nginx 输出日志，有个错误可以忽略1234567891011121314151617Configuration summary + using system PCRE library + OpenSSL library is not used + using system zlib library nginx path prefix: &quot;/usr/local/nginx&quot; nginx binary file: &quot;/usr/bin/nginx&quot; nginx modules path: &quot;/usr/local/nginx/modules&quot; nginx configuration prefix: &quot;/usr/local/nginx/conf&quot; nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot; nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot; nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot; nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot; nginx http client request body temporary files: &quot;client_body_temp&quot; nginx http proxy temporary files: &quot;proxy_temp&quot; nginx http fastcgi temporary files: &quot;fastcgi_temp&quot; nginx http uwsgi temporary files: &quot;uwsgi_temp&quot; nginx http scgi temporary files: &quot;scgi_temp&quot; 3.编译安装1make &amp;&amp; make install 查看安装成功与否1nginx -v 启动与停止 进入/usr/local/nginx/sbin 启动nginx 1./nginx 可通过ps -ef | grep nginx查看nginx是否已启动成功 停止nginx 1./nginx -s stop 重新启动 1./nginx -s reload 配置nginx开机启动将/usr/bin/nginx拷贝到/etc/rc.d/rc.local文件中，rc.local文件会在系统启动的时候执行。但CentOS7建议将开机启动服务写成服务描述文件添加到系统服务中，所以rc.local默认没有执行权限，需要给它添加执行权限。 1234vi /etc/rc.d/rc.local# 添加如下参数/usr/bin/nginxchmod +x /etc/rc.d/rc.local","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://xxk.link/tags/centos/"},{"name":"nginx","slug":"nginx","permalink":"https://xxk.link/tags/nginx/"}]},{"title":"使用 ssr 搭建vpn教程","slug":"category/服务器运维/使用 ssr 搭建vpn教程","date":"2018-04-12T03:27:00.000Z","updated":"2021-09-04T06:32:50.000Z","comments":true,"path":"2018/04/12/category/服务器运维/使用 ssr 搭建vpn教程/","link":"","permalink":"https://xxk.link/2018/04/12/category/服务器运维/使用 ssr 搭建vpn教程/","excerpt":"千万不要购买国内的境外云服务器，本人使用阿里云用了一天被通知关闭，所以一定要买国外的","text":"千万不要购买国内的境外云服务器，本人使用阿里云用了一天被通知关闭，所以一定要买国外的 购买服务器推荐使用性价比高的 vultr 服务器购买和配置 ssr教程 连接 vpn 使用shadowsocks客户端连接 vpn 下载客户端 使用对应的设备下载对应的版本连接 注意：windows 的代理选择系统代理 ，ios移动端app store 搜索 SsrConnectPro 一键安装ss panel[教程][1] [1]: https://www.jianshu.com/p/18ba7b6809cc 12yum install screen wget -y &amp;&amp;screen -S ss wget -N --no-check-certificate https://raw.githubusercontent.com/mmmwhy/ss-panel-and-ss-py-mu/master/ss-panel-v3-mod.sh &amp;&amp; chmod +x ss-panel-v3-mod.sh &amp;&amp; bash ss-panel-v3-mod.sh 输入1 默认账号：91vps默认密码：91vps 节点一键脚本 先在网站新建节点信息，记住node_id 1wget -N --no-check-certificate https://raw.githubusercontent.com/mmmwhy/ss-panel-and-ss-py-mu/master/ss-panel-v3-mod.sh &amp;&amp; chmod +x ss-panel-v3-mod.sh &amp;&amp; bash ss-panel-v3-mod.sh 输入2，之后需要输入前端站点的domain，token，node_id。 doamin： 域名或者ip都可以，前边要加http或者https。不要弄错，否则可能出现无法推送使用记录的情况。mukey(token)：默认回车，除非你另行设置过。node_id：还记得上边那个图里边的ID吗？就是那个了。。。","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"ssr","slug":"ssr","permalink":"https://xxk.link/tags/ssr/"},{"name":"vpn","slug":"vpn","permalink":"https://xxk.link/tags/vpn/"}]},{"title":"phabricator安装教程","slug":"category/服务器运维/phabricator安装教程","date":"2018-04-10T15:31:00.000Z","updated":"2021-09-04T06:29:14.000Z","comments":true,"path":"2018/04/10/category/服务器运维/phabricator安装教程/","link":"","permalink":"https://xxk.link/2018/04/10/category/服务器运维/phabricator安装教程/","excerpt":"本教程采用 docker 安装 请自行 google 安装","text":"本教程采用 docker 安装 请自行 google 安装 安装123docker pull hachque/phabricatordocker run -d --restart=always -p 8082:80 -p 443:443 -p 2222:2222 --env PHABRICATOR_HOST=你的域名 --env MYSQL_HOST= localhost --env MYSQL_USER=root --env MYSQL_PASS=123456 --env PHABRICATOR_REPOSITORY_PATH=/repos -v /storage/phabricator/repo/path:/repos -v /storage/phabricator/local:/srv/phabricator/phabricator/src/extensions hachque/phabricator 设置邮箱通知 进入容器 1docker exec -it 容器 id /bin/bash 进入/srv/phabricator/phabricator/目录 进行有限 smtp 配置 12345./bin/config set phpmailer.smtp-host smtp.exmail.qq.com ./bin/config set phpmailer.smtp-port 465 ./bin/config set phpmailer.smtp-protocol SSL./bin/config set phpmailer.smtp-user 邮箱帐号./bin/config set phpmailer.smtp-password 邮箱密码 安装 中文包 下载中文包中文包 将中文包放到宿主映射的目录下/storage/phabricator/local 对应的是容器下的目录 /srv/phabricator/phabricator/src/extensions 遗留问题 此时进入系统会有两个提示，一个是推荐安装 acpu 和 cdn 配置","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://xxk.link/tags/教程/"},{"name":"phabricator","slug":"phabricator","permalink":"https://xxk.link/tags/phabricator/"}]},{"title":"jenkins 安装教程","slug":"category/服务器运维/jenkins 安装教程","date":"2018-04-10T03:20:00.000Z","updated":"2021-09-04T06:30:40.000Z","comments":true,"path":"2018/04/10/category/服务器运维/jenkins 安装教程/","link":"","permalink":"https://xxk.link/2018/04/10/category/服务器运维/jenkins 安装教程/","excerpt":"本教程采用 docker 安装，请自行 google 安装 docker 教程","text":"本教程采用 docker 安装，请自行 google 安装 docker 教程 安装 jenkins123docker pull jenkinsci/blueoceandocker run -p 8080:8080 jenkinsci/blueocean","categories":[{"name":"服务器运维","slug":"服务器运维","permalink":"https://xxk.link/categories/服务器运维/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://xxk.link/tags/教程/"},{"name":"jenkins","slug":"jenkins","permalink":"https://xxk.link/tags/jenkins/"}]},{"title":"https 访问问题","slug":"category/dotnet/https-config","date":"2017-12-02T13:01:24.000Z","updated":"2021-09-04T03:56:37.000Z","comments":true,"path":"2017/12/02/category/dotnet/https-config/","link":"","permalink":"https://xxk.link/2017/12/02/category/dotnet/https-config/","excerpt":"使用dotnet core 开发微信小程序api,小程序api需要使用https访问，折腾了好久，依旧没有解决。","text":"使用dotnet core 开发微信小程序api,小程序api需要使用https访问，折腾了好久，依旧没有解决。 首先申请免费证书1.腾讯云免费证书(推荐)第一次使用的测试服务器，证书是腾讯云申请的，部署起来非常省事，我想是因为小程序是腾讯的，兼容性好。2.阿里云免费证书正式服务器上申请的是阿里云的免费证书 证书对比，腾讯云的一个是crt结尾的，阿里云的是pem结尾的，部署是用nginx转发的。 配置NGINX123456789101112131415161718# HTTPS server # server &#123; listen 80 default backlog=2048; listen 443 ssl; server_name webapi.zsptserver.top; ssl_certificate /usr/local/nginx/conf/certs/1523082975550.crt; ssl_certificate_key /usr/local/nginx/conf/certs/1523082975550.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_cache shared:SSL:10m; # shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers ECDHE-RSA-AES256-SHA384:AES256-SHA256:RC4:HIGH:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!AESGCM; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:5000; &#125; access_log /usr/local/nginx/logs/wxapi.log; &#125; nginx配置比较简单，直接一个转发就可以了 发布测试1.http可以正常访问，https访问不了？于是关闭防火墙，确实可以访问了2.调用小程序授权的接口报错了，是不是请求第三方https接口需要证书？于是忽略证书校验 1234567using (var handler = new HttpClientHandler())&#123; handler.ServerCertificateCustomValidationCallback = delegate &#123; return true; &#125;; using (var httpClient = new HttpClient(handler))&#123; return httpClient.GetStringAsync(\"http://\" + self.URL + \"/version\").Result; &#125;&#125; 问题还是没有解决，于是开启防火墙，通过测试http访问没有问题了。3.通过这些问题，可以说明防火墙是必须开启的，但是开启后https确无法访问，那么只有一种可能，阿里云服务器的443端口没有对外开放。","categories":[{"name":"dotnet","slug":"dotnet","permalink":"https://xxk.link/categories/dotnet/"}],"tags":[{"name":"https","slug":"https","permalink":"https://xxk.link/tags/https/"},{"name":"config","slug":"config","permalink":"https://xxk.link/tags/config/"}]},{"title":"集成敏感词过滤","slug":"category/java/filtering-of-sensitive-words","date":"2017-12-02T13:01:00.000Z","updated":"2021-09-04T05:58:15.000Z","comments":true,"path":"2017/12/02/category/java/filtering-of-sensitive-words/","link":"","permalink":"https://xxk.link/2017/12/02/category/java/filtering-of-sensitive-words/","excerpt":"很多时候为了防止一些用户发布一些垃圾评论，都需要采用敏感词过滤","text":"很多时候为了防止一些用户发布一些垃圾评论，都需要采用敏感词过滤 敏感词词库地址https://github.com/observerss/textfilter 导入类库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashSet;import java.util.Iterator;import java.util.Map;import java.util.Set;/** * 敏感词过滤 * * @author dxm * */@SuppressWarnings(\"rawtypes\")public class SensitiveWordFilter &#123; private Map sensitiveWordMap = null; // 最小匹配规则 public static int minMatchTYpe = 1; // 最大匹配规则 public static int maxMatchType = 2; // 单例 private static SensitiveWordFilter inst = null; /** * 构造函数，初始化敏感词库 */ private SensitiveWordFilter() &#123; sensitiveWordMap = new SensitiveWordInit().initKeyWord(); &#125; /** * 获取单例 * * @return */ public static SensitiveWordFilter getInstance() &#123; if (null == inst) &#123; inst = new SensitiveWordFilter(); &#125; return inst; &#125; /** * 判断文字是否包含敏感字符 * * @param txt * @param matchType * @return */ public boolean isContaintSensitiveWord(String txt, int matchType) &#123; boolean flag = false; for (int i = 0; i &lt; txt.length(); i++) &#123; // 判断是否包含敏感字符 int matchFlag = this.CheckSensitiveWord(txt, i, matchType); // 大于0存在，返回true if (matchFlag &gt; 0) &#123; flag = true; &#125; &#125; return flag; &#125; /** * 获取文字中的敏感词 * * @param txt * @param matchType * @return */ public Set&lt;String&gt; getSensitiveWord(String txt, int matchType) &#123; Set&lt;String&gt; sensitiveWordList = new HashSet&lt;String&gt;(); for (int i = 0; i &lt; txt.length(); i++) &#123; // 判断是否包含敏感字符 int length = CheckSensitiveWord(txt, i, matchType); // 存在,加入list中 if (length &gt; 0) &#123; sensitiveWordList.add(txt.substring(i, i + length)); // 减1的原因，是因为for会自增 i = i + length - 1; &#125; &#125; return sensitiveWordList; &#125; /** * 替换敏感字字符 * * @param txt * @param matchType * @param replaceChar * @return */ public String replaceSensitiveWord(String txt, int matchType, String replaceChar) &#123; String resultTxt = txt; // 获取所有的敏感词 Set&lt;String&gt; set = getSensitiveWord(txt, matchType); Iterator&lt;String&gt; iterator = set.iterator(); String word = null; String replaceString = null; while (iterator.hasNext()) &#123; word = iterator.next(); replaceString = getReplaceChars(replaceChar, word.length()); resultTxt = resultTxt.replaceAll(word, replaceString); &#125; return resultTxt; &#125; /** * 获取替换字符串 * * @param replaceChar * @param length * @return */ private String getReplaceChars(String replaceChar, int length) &#123; String resultReplace = replaceChar; for (int i = 1; i &lt; length; i++) &#123; resultReplace += replaceChar; &#125; return resultReplace; &#125; /** * 检查文字中是否包含敏感字符，检查规则如下：&lt;br&gt; * 如果存在，则返回敏感词字符的长度，不存在返回0 * * @param txt * @param beginIndex * @param matchType * @return */ public int CheckSensitiveWord(String txt, int beginIndex, int matchType) &#123; // 敏感词结束标识位：用于敏感词只有1位的情况 boolean flag = false; // 匹配标识数默认为0 int matchFlag = 0; Map nowMap = sensitiveWordMap; for (int i = beginIndex; i &lt; txt.length(); i++) &#123; char word = txt.charAt(i); // 获取指定key nowMap = (Map) nowMap.get(word); // 存在，则判断是否为最后一个 if (nowMap != null) &#123; // 找到相应key，匹配标识+1 matchFlag++; // 如果为最后一个匹配规则,结束循环，返回匹配标识数 if (\"1\".equals(nowMap.get(\"isEnd\"))) &#123; // 结束标志位为true flag = true; // 最小规则，直接返回,最大规则还需继续查找 if (SensitiveWordFilter.minMatchTYpe == matchType) &#123; break; &#125; &#125; &#125; // 不存在，直接返回 else &#123; break; &#125; &#125; // 长度必须大于等于1，为词 if (matchFlag &lt; 2 || !flag) &#123; matchFlag = 0; &#125; return matchFlag; &#125; public static void main(String[] args) &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); SensitiveWordFilter filter = SensitiveWordFilter.getInstance(); String txt = \"太多的伤感情怀也许只局限于饲养基地 荧幕中的情节，主人公尝试着去用某种方式渐渐的很潇洒地释自杀指南怀那些自己经历的伤感。\" + \"然后法轮功 我们的扮演的角色就是跟随着主人公的喜红客联盟 怒哀乐而过于牵强的把自己的情感也附加于银幕情节中，然后感动就流泪，\" + \"难过就躺在某一个人的怀里尽情的阐述心扉或者手机卡复制器一个人一杯红酒一部电影在夜三级片 深人静的晚上，关上电话静静的发呆着。\"; txt = \"法轮大法,做鸡\"; System.out.println(sdf.format(new Date())); String hou = filter.replaceSensitiveWord(txt, 1, \"*\"); System.out.println(sdf.format(new Date())); System.out.println(\"替换前的文字为：\" + txt); System.out.println(\"替换后的文字为：\" + hou); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136import java.io.*;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;/** * 初始化敏感词库&lt;br&gt; * 将敏感词加入到HashMap中&lt;br&gt; * 构建DFA算法模型 * * @author dxm * */@SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;)public class SensitiveWordInit &#123; // 字符编码 private String ENCODING = \"UTF-8\"; /** * 初始化敏感字库 * * @return */ public Map initKeyWord() &#123; // 读取敏感词库 Set&lt;String&gt; wordSet = readSensitiveWordFile(); // 将敏感词库加入到HashMap中 return addSensitiveWordToHashMap(wordSet); &#125; /** * 读取敏感词库，将敏感词放入HashSet中，构建一个DFA算法模型：&lt;br&gt; * 中 = &#123; isEnd = 0 国 = &#123;&lt;br&gt; * isEnd = 1 人 = &#123;isEnd = 0 民 = &#123;isEnd = 1&#125; &#125; 男 = &#123; isEnd = 0 人 = &#123; isEnd = * 1 &#125; &#125; &#125; &#125; 五 = &#123; isEnd = 0 星 = &#123; isEnd = 0 红 = &#123; isEnd = 0 旗 = &#123; isEnd = 1 * &#125; &#125; &#125; &#125; * */ private Map addSensitiveWordToHashMap(Set&lt;String&gt; wordSet) &#123; // 初始化敏感词容器，减少扩容操作 Map wordMap = new HashMap(wordSet.size()); for (String word : wordSet) &#123; Map nowMap = wordMap; for (int i = 0; i &lt; word.length(); i++) &#123; // 转换成char型 char keyChar = word.charAt(i); // 获取 Object tempMap = nowMap.get(keyChar); // 如果存在该key，直接赋值 if (tempMap != null) &#123; nowMap = (Map) tempMap; &#125; // 不存在则，则构建一个map，同时将isEnd设置为0，因为他不是最后一个 else &#123; // 设置标志位 Map&lt;String, String&gt; newMap = new HashMap&lt;String, String&gt;(); newMap.put(\"isEnd\", \"0\"); // 添加到集合 nowMap.put(keyChar, newMap); nowMap = newMap; &#125; // 最后一个 if (i == word.length() - 1) &#123; nowMap.put(\"isEnd\", \"1\"); &#125; &#125; &#125; return wordMap; &#125; /** * 读取敏感词库中的内容，将内容添加到set集合中 * * @return * @throws Exception */ private Set&lt;String&gt; readSensitiveWordFile() &#123; Set&lt;String&gt; wordSet = null; // 读取文件 //String app = System.getProperty(\"user.dir\"); //String filePath=this.getServletConfig().getServletContext().getRealPath(\"/\"); String filePath = this.getClass().getClassLoader().getResource(\"\").getPath()+\"/sensi_words.txt\"; File file = new File(filePath); InputStream inputStream = ClassLoader.getSystemResourceAsStream(\"sensi_words.txt\"); try &#123; InputStreamReader read = new InputStreamReader(new FileInputStream(file), ENCODING); // 文件流是否存在 if (file.isFile() &amp;&amp; file.exists()) &#123; wordSet = new HashSet&lt;String&gt;(); StringBuffer sb = new StringBuffer(); BufferedReader bufferedReader = new BufferedReader(read); String txt = null; // 读取文件，将文件内容放入到set中 while ((txt = bufferedReader.readLine()) != null) &#123; sb.append(txt+\",\"); &#125; bufferedReader.close(); String str = sb.toString(); String[] ss = str.split(\",\"); for (String s : ss) &#123; wordSet.add(s); &#125; &#125; // 关闭文件流 read.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return wordSet; &#125;&#125; 调用12345678910SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); SensitiveWordFilter filter = SensitiveWordFilter.getInstance(); String txt = \"太多的伤感情怀也许只局限于饲养基地 荧幕中的情节，主人公尝试着去用某种方式渐渐的很潇洒地释自杀指南怀那些自己经历的伤感。\" + \"然后法轮功 我们的扮演的角色就是跟随着主人公的喜红客联盟 怒哀乐而过于牵强的把自己的情感也附加于银幕情节中，然后感动就流泪，\" + \"难过就躺在某一个人的怀里尽情的阐述心扉或者手机卡复制器一个人一杯红酒一部电影在夜三级片 深人静的晚上，关上电话静静的发呆着。\"; txt = \"法轮大法,做鸡\"; System.out.println(sdf.format(new Date())); String hou = filter.replaceSensitiveWord(txt, 1, \"*\"); System.out.println(sdf.format(new Date())); System.out.println(\"替换前的文字为：\" + txt); System.out.println(\"替换后的文字为：\" + hou);","categories":[{"name":"java","slug":"java","permalink":"https://xxk.link/categories/java/"}],"tags":[{"name":"过滤","slug":"过滤","permalink":"https://xxk.link/tags/过滤/"},{"name":"敏感词","slug":"敏感词","permalink":"https://xxk.link/tags/敏感词/"}]}]}